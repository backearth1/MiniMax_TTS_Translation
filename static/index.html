<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniMax TTSé…éŸ³ç¿»è¯‘å·¥å…·</title>
    <link rel="icon" type="image/png" href="/static/mm_logo.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="/static/css/style.css" rel="stylesheet">
    <link href="/static/css/project-manager.css" rel="stylesheet">
    <link href="/static/css/progress-tracker.css" rel="stylesheet">
    <link href="/static/css/inline-editor.css" rel="stylesheet">
    <link href="/static/css/main-theme.css" rel="stylesheet">
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar navbar-expand-lg">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1 text-dark d-flex align-items-center">
                <img src="/static/mm_logo.png" alt="MiniMax" style="height: 32px; width: auto; margin-right: 8px;">MiniMax TTSé…éŸ³ç¿»è¯‘å·¥å…·
            </span>
        </div>
    </nav>

    <div class="container-fluid p-4">
        <!-- æ–°å¸ƒå±€ï¼šå·¦ä¾§SRTå¤„ç†ï¼Œå³ä¾§å‚æ•°é…ç½®å’Œæ§åˆ¶åŒº -->
        <div class="row g-4">
            <!-- å·¦ä¾§ï¼šSRTå¤„ç†åŒºåŸŸ -->
            <div class="col-lg-8">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="bi bi-gear-wide-connected me-2"></i>SRTå¤„ç†</h5>
                    </div>
                    <div class="card-body">
                        <!-- ä¸‰ç»„æŒ‰é’®å¸ƒå±€ -->
                        <div class="row g-3 mb-4">
                            <!-- ç¬¬ä¸€ç»„ï¼šSRTä¸Šä¼ ä¸‹è½½ -->
                            <div class="col-md-4">
                                <h6 class="text-muted mb-2"><i class="bi bi-file-earmark-text me-1"></i>SRTæ–‡ä»¶</h6>
                                <div class="d-grid gap-2">
                                    <input type="file" id="quickSrtUpload" accept=".srt" style="display: none;">
                                    <button class="btn btn-primary btn-sm" onclick="document.getElementById('quickSrtUpload').click()">
                                        <i class="bi bi-upload me-1"></i>ä¸Šä¼ SRT
                                    </button>
                                    <button class="btn btn-warning btn-sm" id="exportSrtBtn" onclick="exportSrtFile()" style="display: none;">
                                        <i class="bi bi-download me-1"></i>å¯¼å‡ºSRT
                                    </button>
                                </div>
                            </div>

                            <!-- ç¬¬äºŒç»„ï¼šé¡¹ç›®ç®¡ç† -->
                            <div class="col-md-4">
                                <h6 class="text-muted mb-2"><i class="bi bi-folder2-open me-1"></i>é¡¹ç›®ç®¡ç†</h6>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-info btn-sm" onclick="toggleProjectManager()" id="projectManagerToggle">
                                        <i class="bi bi-collection me-1"></i>æˆ‘çš„é¡¹ç›®
                                        <span class="badge bg-light text-dark ms-1" id="projectCountBadge">0/5</span>
                                    </button>
                                    <button class="btn btn-secondary btn-sm" onclick="refreshProjectList()">
                                        <i class="bi bi-arrow-clockwise me-1"></i>åˆ·æ–°é¡¹ç›®
                                    </button>
                                </div>
                            </div>

                            <!-- ç¬¬ä¸‰ç»„ï¼šæ‰¹é‡ä¿®æ”¹è¯´è¯äºº -->
                            <div class="col-md-4">
                                <h6 class="text-muted mb-2"><i class="bi bi-people me-1"></i>æ‰¹é‡æ“ä½œ</h6>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-outline-primary btn-sm" onclick="toggleBatchSpeakerPanel()" id="batchSpeakerToggle">
                                        <i class="bi bi-people-fill me-1"></i>æ‰¹é‡æ”¹è¯´è¯äºº
                                    </button>
                                    <button class="btn btn-outline-success btn-sm" onclick="selectAllSegments()" id="selectAllBtn">
                                        <i class="bi bi-check-all me-1"></i>å…¨é€‰æ®µè½
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- é¡¹ç›®ç®¡ç†é¢æ¿ - ç»„ä»¶åŒ– -->
                        <div id="projectPanelSection"></div>

                        <!-- æ‰¹é‡æ“ä½œé¢æ¿ - ç»„ä»¶åŒ– -->
                        <div id="batchPanelSection"></div>

                        <!-- ç¿»è¯‘åŠŸèƒ½åŒºåŸŸ -->
                        <div class="d-flex gap-2 justify-content-center mb-3" id="translationSection" style="display: none;">
                        </div>

                        <!-- å­—å¹•æ®µè½åˆ—è¡¨ -->
                        <div class="subtitle-editor" id="subtitleEditor" style="min-height: 200px;">
                            <div class="text-center py-5" style="color: var(--pink-400);">
                                <i class="bi bi-hourglass-split fs-1"></i>
                                <p class="mt-2">æ­£åœ¨åŠ è½½ç¤ºä¾‹å­—å¹•æ–‡ä»¶...</p>
                            </div>
                        </div>

                        <!-- åˆ†é¡µæ§åˆ¶ -->
                        <div class="d-flex justify-content-between align-items-center mt-3" id="paginationControls" style="display: none;">
                            <button class="btn btn-sm btn-outline-primary" id="prevPage" disabled>
                                <i class="bi bi-chevron-left"></i> ä¸Šä¸€é¡µ
                            </button>
                            <span id="pageInfo" style="color: var(--pink-600);">ç¬¬ 1 é¡µ</span>
                            <button class="btn btn-sm btn-outline-primary" id="nextPage" disabled>
                                ä¸‹ä¸€é¡µ <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šå‚æ•°é…ç½®å’Œæ§åˆ¶åŒº -->
            <div class="col-lg-4">
                <!-- ä¸ŠåŠéƒ¨åˆ†ï¼šå‚æ•°é…ç½® -->
                <div class="row g-4 mb-5">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="bi bi-gear-fill me-2"></i>é…ç½®å‚æ•°</h5>
                            </div>
                            <div class="card-body config-section">
                                <form id="configForm">
                                    <!-- APIé…ç½® -->
                                    <div class="row g-3 mb-3">
                                        <div class="col-6">
                                            <label for="groupId" class="form-label">
                                                Group ID
                                                <i class="bi bi-info-circle text-muted" title="å°†è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨"></i>
                                            </label>
                                            <input type="text" class="form-control" id="groupId" required style="border-color: #2196f3;" placeholder="è¾“å…¥æ‚¨çš„Group ID">
                                        </div>
                                        <div class="col-6">
                                            <label for="apiKey" class="form-label">
                                                API Key
                                                <i class="bi bi-info-circle text-muted" title="å°†è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨"></i>
                                            </label>
                                            <input type="password" class="form-control" id="apiKey" required style="border-color: #2196f3;" placeholder="è¾“å…¥æ‚¨çš„API Key">
                                        </div>
                                    </div>
                                    
                                    
                                    <!-- APIç«¯ç‚¹é€‰æ‹© -->
                                    <div class="row g-3 mb-3">
                                        <div class="col-12">
                                            <label for="apiEndpoint" class="form-label">
                                                <i class="bi bi-globe"></i> APIæ¥å…¥ç‚¹
                                            </label>
                                            <select class="form-select" id="apiEndpoint" style="border-color: #2196f3;">
                                                <option value="domestic" selected>ğŸ‡¨ğŸ‡³ å›½å†… (api.minimaxi.com)</option>
                                                <option value="overseas">ğŸŒ æµ·å¤– (api.minimax.io)</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- è¯­éŸ³é…ç½® -->
                                    <div class="row g-3 mb-3">
                                        <div class="col-8">
                                            <label for="voiceModel" class="form-label">è¯­éŸ³æ¨¡å‹</label>
                                            <input type="text" class="form-control" id="voiceModel" value="speech-02-hd">
                                        </div>
                                        <div class="col-4">
                                            <label for="language" class="form-label">è¯­è¨€</label>
                                            <select class="form-select" id="language">
                                                <option value="Chinese">ä¸­æ–‡</option>
                                                <option value="Chinese,Yue">ç²¤è¯­</option>
                                                <option value="English">è‹±è¯­</option>
                                                <option value="Arabic">é˜¿æ‹‰ä¼¯è¯­</option>
                                                <option value="Russian">ä¿„è¯­</option>
                                                <option value="Spanish">è¥¿ç­ç‰™è¯­</option>
                                                <option value="French">æ³•è¯­</option>
                                                <option value="Portuguese">è‘¡è„ç‰™è¯­</option>
                                                <option value="German">å¾·è¯­</option>
                                                <option value="Turkish">åœŸè€³å…¶è¯­</option>
                                                <option value="Dutch">è·å…°è¯­</option>
                                                <option value="Ukrainian">ä¹Œå…‹å…°è¯­</option>
                                                <option value="Vietnamese">è¶Šå—è¯­</option>
                                                <option value="Indonesian">å°å°¼è¯­</option>
                                                <option value="Japanese">æ—¥è¯­</option>
                                                <option value="Italian">æ„å¤§åˆ©è¯­</option>
                                                <option value="Korean">éŸ©è¯­</option>
                                                <option value="Thai">æ³°è¯­</option>
                                                <option value="Polish">æ³¢å…°è¯­</option>
                                                <option value="Romanian">ç½—é©¬å°¼äºšè¯­</option>
                                                <option value="Greek">å¸Œè…Šè¯­</option>
                                                <option value="Czech">æ·å…‹è¯­</option>
                                                <option value="Finnish">èŠ¬å…°è¯­</option>
                                                <option value="Hindi">å°åœ°è¯­</option>
                                                <option value="Bulgarian">ä¿åŠ åˆ©äºšè¯­</option>
                                                <option value="Danish">ä¸¹éº¦è¯­</option>
                                                <option value="Hebrew">å¸Œä¼¯æ¥è¯­</option>
                                                <option value="Malay">é©¬æ¥è¯­</option>
                                                <option value="Persian">æ³¢æ–¯è¯­</option>
                                                <option value="Slovak">æ–¯æ´›ä¼å…‹è¯­</option>
                                                <option value="Swedish">ç‘å…¸è¯­</option>
                                                <option value="Croatian">å…‹ç½—åœ°äºšè¯­</option>
                                                <option value="Filipino">è²å¾‹å®¾è¯­</option>
                                                <option value="Hungarian">åŒˆç‰™åˆ©è¯­</option>
                                                <option value="Norwegian">æŒªå¨è¯­</option>
                                                <option value="Slovenian">æ–¯æ´›æ–‡å°¼äºšè¯­</option>
                                                <option value="Catalan">åŠ æ³°ç½—å°¼äºšè¯­</option>
                                                <option value="Nynorsk">æ–°æŒªå¨è¯­</option>
                                                <option value="Tamil">æ³°ç±³å°”è¯­</option>
                                                <option value="Afrikaans">å—éè·å…°è¯­</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- è§’è‰²è¯­éŸ³é…ç½® -->
                                    <div class="row g-3 mb-3">
                                        <div class="col-6">
                                            <label for="speaker00Voice" class="form-label">SPEAKER_00 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker00Voice" value="ai_her_04">
                                        </div>
                                        <div class="col-6">
                                            <label for="speaker01Voice" class="form-label">SPEAKER_01 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker01Voice" value="wumei_yujie">
                                        </div>
                                    </div>
                                    <div class="row g-3 mb-3">
                                        <div class="col-6">
                                            <label for="speaker02Voice" class="form-label">SPEAKER_02 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker02Voice" value="uk_oldwoman4">
                                        </div>
                                        <div class="col-6">
                                            <label for="speaker03Voice" class="form-label">SPEAKER_03 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker03Voice" value="female-chengshu">
                                        </div>
                                    </div>
                                    <div class="row g-3 mb-3">
                                        <div class="col-6">
                                            <label for="speaker04Voice" class="form-label">SPEAKER_04 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker04Voice" value="Serene_Elder">
                                        </div>
                                        <div class="col-6">
                                            <label for="speaker05Voice" class="form-label">SPEAKER_05 è¯­éŸ³</label>
                                            <input type="text" class="form-control" id="speaker05Voice" value="Serene_Elder">
                                        </div>
                                    </div>
                                    
                                    <!-- è‡ªå®šä¹‰è§’è‰²åŒºåŸŸ -->
                                    <div id="customSpeakersContainer"></div>
                                    
                                    <!-- å¢åŠ è§’è‰²æŒ‰é’® -->
                                    <div class="row g-3 mb-3">
                                        <div class="col-12">
                                            <button type="button" class="btn btn-outline-primary btn-sm w-100" onclick="showAddSpeakerModal()">
                                                <i class="bi bi-person-plus me-1"></i>å¢åŠ è‡ªå®šä¹‰è§’è‰²
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ï¼Œç”¨äºå…¼å®¹ç°æœ‰ç”Ÿæˆé€»è¾‘ -->
                                    <input type="file" id="subtitleFile" accept=".srt,.txt" style="display: none;">
                                </form>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ä¸‹åŠéƒ¨åˆ†ï¼šæ§åˆ¶åŒºåŸŸ -->
                <div class="row g-3">
                    <!-- éšè—çš„çŠ¶æ€å’Œä¸‹è½½æŒ‰é’®ï¼Œä¿ç•™åŠŸèƒ½ -->
                    <div class="col-12" style="display: none;">
                        <div class="text-center">
                            <!-- éšè—çš„çŠ¶æ€å’Œä¸‹è½½æŒ‰é’®ï¼Œä¿ç•™åŠŸèƒ½ -->
                            <div style="display: none;">
                                <span class="badge px-3 py-2" id="statusBadge">å‡†å¤‡å°±ç»ª</span>
                                <button class="btn btn-primary btn-lg w-100 mt-2" id="downloadBtn" style="display: none;">
                                    <i class="bi bi-download me-2"></i>ä¸‹è½½éŸ³é¢‘æ–‡ä»¶
                                </button>
                            </div>
                        </div>
                    </div>


                    <!-- éŸ³é¢‘æ’­æ”¾å™¨åŒº - ç»„ä»¶åŒ– -->
                    <div id="audioPlayerSection"></div>

                    <!-- æ—¥å¿—å±•ç¤ºåŒº - ç»„ä»¶åŒ– -->
                    <div id="logDisplaySection"></div>

                    <!-- ä½¿ç”¨è¯´æ˜åŒº -->
                    <div class="col-12">
                        <div class="card">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="bi bi-question-circle me-2"></i>ä½¿ç”¨è¯´æ˜</h5>
                            </div>
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-12">
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">1. ä½¿ç”¨è¯´æ˜</h6>
                                            <p class="mb-2">æœ¬ç½‘ç«™ä»…ç”¨äºæµ‹è¯•ä½“éªŒï¼Œåœ¨çº¿äººæ•°å¤šæ—¶å°†è‡ªåŠ¨é™æµï¼Œå¦‚æœé•¿æœŸå•†ä¸šåŒ–ä½¿ç”¨ï¼Œè¯·ä¸‹è½½å¼€æºç‰ˆæœ¬è‡ªè¡Œéƒ¨ç½² <a href="https://github.com/backearth1/MiniMax_TTS_Translation" target="_blank" class="text-decoration-none">https://github.com/backearth1/MiniMax_TTS_Translation</a></p>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">2. APIé…ç½®</h6>
                                            <p class="mb-2">è¯·åˆ°<a href="https://platform.minimaxi.com" target="_blank" class="text-decoration-none">MiniMaxå¼€æ”¾å¹³å°</a>æ³¨å†Œè·å–api_keyï¼Œåœ°å€ "https://platform.minimaxi.com", ä½¿ç”¨é—®é¢˜è¯·è”ç³»MiniMaxæŠ€æœ¯æ”¯æŒæˆ–é‚®ä»¶<a href="mailto:devin@minimaxi.com" class="text-decoration-none">devin@minimaxi.com</a></p>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">3. å»ºè®®æµç¨‹</h6>
                                            <ol class="mb-2">
                                                <li>ä¸Šä¼ SRTæ–‡ä»¶</li>
                                                <li>ç¼–è¾‘ä¼˜åŒ–SRTçš„æ–‡æœ¬ï¼Œè§’è‰²ï¼Œæƒ…ç»ªç­‰</li>
                                                <li>æ‰¹é‡ç”Ÿæˆ</li>
                                                <li>åˆæˆé¢„è§ˆï¼Œæ ¹æ®æ•ˆæœï¼Œå†è¿”å›ä¼˜åŒ–æ–‡æœ¬</li>
                                            </ol>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">4. ä¸€é”®ç¿»è¯‘åŠŸèƒ½</h6>
                                            <p class="mb-2">ç‚¹å‡»"ä¸€é”®ç¿»è¯‘"æŒ‰é’®å¯è‡ªåŠ¨å®Œæˆä»¥ä¸‹æµç¨‹ï¼š</p>
                                            <ol class="mb-2">
                                                <li><strong>æ‰¹é‡ç¿»è¯‘</strong>ï¼šå°†åŸæ–‡ç¿»è¯‘ä¸ºç›®æ ‡è¯­è¨€</li>
                                                <li><strong>æ‰¹é‡TTS</strong>ï¼šä¸ºç¿»è¯‘åçš„æ–‡æœ¬ç”Ÿæˆè¯­éŸ³</li>
                                                <li><strong>æ‹¼æ¥éŸ³é¢‘</strong>ï¼šå°†æ‰€æœ‰éŸ³é¢‘ç‰‡æ®µæ‹¼æ¥ä¸ºå®Œæ•´æ–‡ä»¶</li>
                                            </ol>
                                            <p class="mb-2"><small class="text-muted">æ³¨æ„ï¼šä¸€é”®ç¿»è¯‘ä¼šä½¿ç”¨å½“å‰é…ç½®çš„è¯­è¨€è®¾ç½®ï¼Œè¯·ç¡®ä¿å·²æ­£ç¡®é…ç½®APIå‚æ•°</small></p>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">5. æ‰¹é‡TTSæ—¶é—´æˆ³å¯¹é½å¤„ç†é€»è¾‘</h6>
                                            <p class="mb-2">ç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†TTSç”ŸæˆéŸ³é¢‘ä¸å­—å¹•æ—¶é—´æˆ³çš„å¯¹é½é—®é¢˜ï¼š</p>
                                            <ul class="mb-2">
                                                <li><strong>ç¿»è¯‘ä¼˜åŒ–</strong>ï¼šå½“åŠ é€Ÿæ¯”ä¾‹ > 1.3 æ—¶ï¼Œç³»ç»Ÿä¼šå°è¯•é‡æ–°ç¿»è¯‘æ–‡æœ¬ä»¥ç¼©çŸ­å†…å®¹</li>
                                                <li><strong>é€Ÿåº¦è°ƒæ•´</strong>ï¼šå½“åŠ é€Ÿæ¯”ä¾‹ â‰¤ 1.3 æˆ–ç¿»è¯‘ä¼˜åŒ–æ— æ•ˆæ—¶ï¼Œä¼šé€æ­¥è°ƒæ•´è¯­é€Ÿå‚æ•°ï¼ˆ1.0 â†’ 1.2 â†’ 1.4 â†’ 2.0ï¼‰</li>
                                                <li><strong>å¤±è´¥å¤„ç†</strong>ï¼šå½“é€Ÿåº¦è¾¾åˆ°2.0ä¸”æ¯”ä¾‹ä» > 1.0æ—¶ï¼Œè¯¥æ®µè½ä¼šè¢«æ ‡è®°ä¸ºå¤±è´¥å¹¶ä½¿ç”¨é™éŸ³</li>
                                                <li><strong>æ‰‹åŠ¨ä¼˜åŒ–</strong>ï¼šå»ºè®®æ ¹æ®å®é™…æ•ˆæœæ‰‹åŠ¨è°ƒæ•´æ–‡æœ¬é•¿åº¦ï¼Œä»¥è·å¾—æœ€ä½³å¯¹é½æ•ˆæœ</li>
                                            </ul>
                                            <p class="mb-2"><small class="text-muted">æ³¨ï¼šåŠ é€Ÿæ¯”ä¾‹ = TTSéŸ³é¢‘æ—¶é•¿ / å­—å¹•æ—¶é•¿ï¼Œæ¯”ä¾‹ â‰¤ 1.0 è¡¨ç¤ºéŸ³é¢‘æ—¶é•¿åœ¨å­—å¹•æ—¶é•¿èŒƒå›´å†…</small></p>
                                        </div>
                                        
                                        <div class="mb-3">
                                            <h6 class="fw-bold text-primary">6. SRTæ ¼å¼æ”¯æŒ</h6>
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h6 class="fw-bold text-success">æœ‰åºå·</h6>
                                                    <pre class="bg-light p-2 rounded small">1
00:00:06.879 --> 00:00:11.039
å—¨ï¼Œä½ å¥½å•Š</pre>
                                                </div>
                                                <div class="col-md-4">
                                                    <h6 class="fw-bold text-success">æ— åºå·</h6>
                                                    <pre class="bg-light p-2 rounded small">00:00:06.879 --> 00:00:11.039
å—¨ï¼Œä½ å¥½å•Š</pre>
                                                </div>
                                                <div class="col-md-4">
                                                    <h6 class="fw-bold text-success">å®Œæ•´æ ‡æ³¨</h6>
                                                    <pre class="bg-light p-2 rounded small">1
[00:00:06.879 --> 00:00:11.039] SPEAKER_00 [emotion: happy]
å—¨ï¼Œä½ å¥½å•Š</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ¨¡æ€æ¡†åŒºåŸŸ - ç»„ä»¶åŒ– -->
    <div id="modalsSection"></div>


    <!-- Toast é€šçŸ¥ -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="toast" class="toast" role="alert">
            <div class="toast-header">
                <i class="bi bi-bell-fill me-2"></i>
                <strong class="me-auto">ç³»ç»Ÿé€šçŸ¥</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
            </div>
            <div class="toast-body" id="toastBody">
                <!-- Toast å†…å®¹ -->
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/core.js"></script>
    <script src="/static/js/component-loader.js"></script>
    <script src="/static/js/app.js"></script>
    <script src="/static/js/project-manager.js"></script>
    <script src="/static/js/progress-tracker.js"></script>
    <script src="/static/js/text-adjuster.js"></script>
    <script src="/static/js/inline-editor.js"></script>
    <script>
        // å¯¼å‡ºSRTæ–‡ä»¶å‡½æ•°
        async function exportSrtFile() {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }

            try {
                // ä½¿ç”¨ä¸“é—¨çš„å¯¼å‡ºAPI
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/export-srt`);
                const result = await response.json();
                
                if (result.success && result.srt_content) {
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const blob = new Blob([result.srt_content], { type: 'text/plain;charset=utf-8' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = result.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    showToast('SRTæ–‡ä»¶å¯¼å‡ºæˆåŠŸï¼');
                } else {
                    showToast('å¯¼å‡ºå¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('å¯¼å‡ºSRTå¤±è´¥:', error);
                showToast('å¯¼å‡ºå¤±è´¥: ' + error.message);
            }
        }
    </script>
    <script>
        // åˆå¹¶å­—å¹•ç¼–è¾‘åŠŸèƒ½åˆ°ä¸»é¡µé¢
        let currentSubtitleProject = null;
        let currentPage = 1;
        let segments = [];

        // ç®€åŒ–ä¸Šä¼ SRTåŠŸèƒ½
        document.getElementById('quickSrtUpload').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleQuickSrtUpload(e.target.files[0]);
            }
        });

        async function handleQuickSrtUpload(file) {
            if (!file.name.toLowerCase().endsWith('.srt')) {
                showToast('è¯·é€‰æ‹©SRTæ ¼å¼æ–‡ä»¶');
                return;
            }

            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('clientId', app.clientId); // æ·»åŠ çœŸå®çš„clientId

                const response = await fetch('/api/parse-subtitle', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    currentSubtitleProject = result.project;
                    currentPage = 1; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                    loadSubtitleSegments();
                    
                    // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                    document.getElementById('exportSrtBtn').style.display = 'inline-block';
                    
                    // åŒæ—¶è®¾ç½®åˆ°éšè—çš„æ–‡ä»¶è¾“å…¥ä¸­ï¼Œç”¨äºå…¼å®¹ç°æœ‰ç”Ÿæˆé€»è¾‘
                    const hiddenFileInput = document.getElementById('subtitleFile');
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    hiddenFileInput.files = dt.files;
                    
                    showToast(`è§£ææˆåŠŸï¼${result.project.total_segments} ä¸ªæ®µè½ï¼Œæ¯é¡µæ˜¾ç¤º20æ¡`);
                } else {
                    showToast('è§£æå¤±è´¥: ' + result.message);
                }
            } catch (error) {
                showToast('ä¸Šä¼ å¤±è´¥: ' + error.message);
            }
        }

        async function loadSubtitleSegments() {
            if (!currentSubtitleProject) return;

            try {
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/segments?page=${currentPage}&per_page=20`);
                const result = await response.json();

                if (result.success) {
                    segments = result.segments;
                    renderSubtitleSegments();
                    updatePaginationInfo(result.pagination);
                    
                    // æ˜¾ç¤ºç¿»è¯‘åŠŸèƒ½åŒºåŸŸ
                    const translationSection = document.getElementById('translationSection');
                    if (translationSection) {
                        translationSection.style.display = 'flex';
                    }
                    
                    // æ˜¾ç¤ºå¯¼å‡ºSRTæŒ‰é’®
                    const exportSrtBtn = document.getElementById('exportSrtBtn');
                    if (exportSrtBtn) {
                        exportSrtBtn.style.display = 'inline-block';
                    }
                    
                    // ç¡®ä¿æ‰¹é‡æ“ä½œåŒºåŸŸå·²åˆå§‹åŒ–ä½†éšè—
                    const batchOperationSection = document.getElementById('batchOperationSection');
                    if (batchOperationSection && segments.length > 0) {
                        // ä¸è¦è‡ªåŠ¨æ˜¾ç¤ºï¼Œç­‰ç”¨æˆ·é€‰æ‹©æ—¶å†æ˜¾ç¤º
                        updateSelectedCount();
                    }
                }
            } catch (error) {
                console.error('åŠ è½½æ®µè½å¤±è´¥:', error);
            }
        }

        function updatePaginationInfo(pagination) {
            if (!pagination) return;
            
            const pageInfo = document.getElementById('pageInfo');
            const paginationControls = document.getElementById('paginationControls');
            const prevPage = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            
            if (pageInfo) {
                pageInfo.textContent = `ç¬¬ ${pagination.page} é¡µï¼Œå…± ${pagination.pages} é¡µ (${pagination.total} æ¡ï¼Œæ¯é¡µ20æ¡)`;
            }
            
            // æ˜¾ç¤ºåˆ†é¡µæ§åˆ¶
            if (pagination.pages > 1) {
                paginationControls.style.display = 'flex';
                prevPage.disabled = pagination.page <= 1;
                nextPage.disabled = pagination.page >= pagination.pages;
            } else {
                paginationControls.style.display = 'none';
            }
        }

        function renderSubtitleSegments() {
            const container = document.getElementById('subtitleEditor');
            
            if (segments.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-5" style="color: var(--pink-400);">
                        <i class="bi bi-file-earmark-text fs-1"></i>
                        <p class="mt-2">ä¸Šä¼ SRTæ–‡ä»¶å¼€å§‹ç¼–è¾‘</p>
                    </div>
                `;
                return;
            }

            const segmentsHtml = segments.map((segment, index) => `
                <div class="segment-item">
                    <div class="d-flex flex-column">
                        <div class="d-flex align-items-center gap-2 mb-1">
                            <input type="checkbox" class="form-check-input segment-checkbox" 
                                   data-segment-id="${segment.id}" 
                                   onchange="updateSelectedCount()"
                                   style="margin-right: 8px;">
                            <span class="badge" style="background: var(--pink-400);">${segment.index}</span>
                            <small style="color: var(--pink-600);">${segment.start_time} â†’ ${segment.end_time}</small>
                            <span class="speaker-simple">${segment.speaker}</span>
                            <span class="emotion-simple">${segment.emotion}</span>
                            <small style="color: var(--pink-600);">Ã—${segment.speed}</small>
                            <div class="btn-group btn-group-sm ms-auto" role="group">
                                <button class="btn btn-outline-primary btn-sm" 
                                        onclick="generateTTS('${segment.id}')" 
                                        title="ç”ŸæˆTTS"
                                        style="width: 70px; min-width: 70px; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; white-space: nowrap;">
                                    ç”Ÿæˆ
                                </button>
                                <button class="btn btn-outline-success btn-sm" 
                                        onclick="playAudio('${segment.id}')" 
                                        ${segment.audio_url && segment.audio_url !== '' ? '' : 'disabled'}
                                        title="æ’­æ”¾éŸ³é¢‘"
                                        style="width: 40px; display: flex; align-items: center; justify-content: center;">
                                    <i class="bi bi-play-circle"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-info insert-segment-btn" 
                                        data-segment-id="${segment.id}"
                                        title="åœ¨æ­¤æ®µè½åæ’å…¥æ–°æ®µè½"
                                        style="width: 40px; display: flex; align-items: center; justify-content: center;">
                                    <i class="bi bi-plus"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="deleteSegment('${segment.id}')"
                                        title="åˆ é™¤æ®µè½"
                                        style="width: 40px; display: flex; align-items: center; justify-content: center;">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="d-flex">
                            <div class="flex-grow-1">
                                <div class="mb-1">
                                    <small style="color: var(--pink-700); font-weight: 500;">åŸæ–‡: ${segment.text}</small>
                                </div>
                                ${segment.translated_text ? 
                                    `<div class="mb-1 d-flex align-items-center">
                                        <small style="color: var(--blue-600); font-weight: 500;" class="translation-text">è¯‘æ–‡: ${segment.translated_text}</small>
                                        <div class="text-adjustment-buttons d-inline-flex gap-1 ms-2">
                                            <button type="button" class="btn btn-outline-primary btn-sm text-adjust-btn" 
                                                    data-segment-id="${segment.id}" 
                                                    data-adjustment-type="shorten"
                                                    title="ç¼©çŸ­è¯‘æ–‡çº¦20%"
                                                    onclick="adjustSegmentText('${segment.id}', 'shorten')">
                                                <i class="bi bi-arrow-down-circle me-1"></i>ç¼©çŸ­
                                            </button>
                                            <button type="button" class="btn btn-outline-success btn-sm text-adjust-btn"
                                                    data-segment-id="${segment.id}"
                                                    data-adjustment-type="lengthen"
                                                    title="åŠ é•¿è¯‘æ–‡çº¦20%"
                                                    onclick="adjustSegmentText('${segment.id}', 'lengthen')">
                                                <i class="bi bi-arrow-up-circle me-1"></i>åŠ é•¿
                                            </button>
                                        </div>
                                    </div>` : 
                                    `<div class="mb-1 d-flex align-items-center">
                                        <small style="color: var(--gray-500); font-style: italic;">è¯‘æ–‡: æœªç¿»è¯‘</small>
                                        <div class="text-adjustment-buttons d-inline-flex gap-1 ms-2">
                                            <small class="text-muted fst-italic">éœ€è¦å…ˆç¿»è¯‘</small>
                                        </div>
                                    </div>`
                                }
                            </div>
                            <div class="ms-2" style="min-width: 120px;">
                                ${segment.trace_id && !segment.trace_id.startsWith('test_') ? `<small class="text-muted" title="${segment.trace_id}">Trace: ${segment.trace_id}</small>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');

            container.innerHTML = segmentsHtml;
            
            // é‡æ–°æ¸²æŸ“åï¼Œç¡®ä¿å†…è”ç¼–è¾‘å™¨é‡æ–°åˆå§‹åŒ–
            if (window.inlineEditor) {
                // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå®Œå…¨æ›´æ–°
                setTimeout(() => {
                    console.log('ğŸ”§ æ‰‹åŠ¨é‡æ–°åˆå§‹åŒ–å†…è”ç¼–è¾‘å™¨');
                    window.inlineEditor.enhanceAllSegments();
                }, 50);
            }
        }

        // TTSç”Ÿæˆå‡½æ•°
        async function generateTTS(segmentId) {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }

            const segment = segments.find(s => s.id === segmentId);
            if (!segment) {
                showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æ®µè½');
                return;
            }

            addLog(`å¼€å§‹ç”ŸæˆTTS: æ®µè½${segmentId}`);

            try {
                // è·å–å½“å‰é…ç½®
                const groupId = document.getElementById('groupId').value;
                const apiKey = document.getElementById('apiKey').value;
                const model = document.getElementById('voiceModel').value;
                const language = document.getElementById('language').value;
                
                // è·å–voiceMappingï¼ˆä»åŠ¨æ€ç”Ÿæˆçš„å…ƒç´ ä¸­ï¼‰
                const voiceMapping = getVoiceMapping();

                if (!groupId || !apiKey) {
                    addLog('é…ç½®é”™è¯¯: ç¼ºå°‘Group IDæˆ–API Key');
                    showToast('è¯·å…ˆé…ç½®Group IDå’ŒAPI Key');
                    return;
                }

                addLog(`è°ƒç”¨TTS API: æ¨¡å‹=${model}, è¯´è¯äºº=${segment.speaker}, æƒ…ç»ª=${segment.emotion}`);
                showToast('æ­£åœ¨ç”ŸæˆTTS...');

                const formData = new FormData();
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('apiEndpoint', document.getElementById('apiEndpoint').value);
                formData.append('model', model);
                formData.append('language', language);
                formData.append('voiceMapping', JSON.stringify(voiceMapping));

                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/segment/${segmentId}/generate-tts`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    const traceInfo = result.trace_id ? `, trace_id=${result.trace_id}` : '';
                    const ratioInfo = result.duration_ratio ? `, æ¯”ä¾‹=${result.duration_ratio.toFixed(2)}` : '';
                    addLog(`TTSç”ŸæˆæˆåŠŸ: æ®µè½${segmentId}${traceInfo}${ratioInfo}`);
                    showToast('TTSç”ŸæˆæˆåŠŸï¼');
                    // é‡æ–°åŠ è½½æ®µè½ä»¥æ›´æ–°çŠ¶æ€
                    loadSubtitleSegments();
                } else {
                    // ç”Ÿæˆå¤±è´¥ï¼Œè®°å½•è¯¦ç»†ä¿¡æ¯ä½†ä¸æ›´æ–°ç•Œé¢
                    const traceInfo = result.trace_id ? `, trace_id=${result.trace_id}` : '';
                    const ratioInfo = result.duration_ratio ? `, æ¯”ä¾‹=${result.duration_ratio.toFixed(2)}` : '';
                    const durationInfo = result.target_duration && result.current_duration ? 
                        `, ç›®æ ‡æ—¶é•¿=${result.target_duration}ms, å½“å‰æ—¶é•¿=${result.current_duration}ms` : '';
                    
                    addLog(`TTSç”Ÿæˆå¤±è´¥: æ®µè½${segmentId}${traceInfo}${ratioInfo}${durationInfo}`);
                    addLog(`å¤±è´¥åŸå› : ${result.message}`);
                    showToast('TTSç”Ÿæˆå¤±è´¥: ' + result.message);
                    // ä¸é‡æ–°åŠ è½½æ®µè½ï¼Œä¿æŒåŸæœ‰çŠ¶æ€
                }
            } catch (error) {
                console.error('TTSç”Ÿæˆå¤±è´¥:', error);
                addLog(`TTSç”Ÿæˆå¤±è´¥: æ®µè½${segmentId}, é”™è¯¯=${error.message}`);
                showToast('TTSç”Ÿæˆå¤±è´¥: ' + error.message);
            }
        }

        // ç”Ÿæˆå®¢æˆ·ç«¯ID
        function generateClientId() {
            return 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // æ·»åŠ æ–°æ®µè½
        async function addNewSegment() {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }

            // ç”Ÿæˆæ–°çš„æ®µè½ID
            const newSegmentId = 'segment_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // è®¡ç®—æ–°çš„æ—¶é—´æˆ³ï¼ˆåœ¨æœ€åä¸€ä¸ªæ®µè½ä¹‹åï¼‰
            let newStartTime = '00:00:00,000';
            let newEndTime = '00:00:05,000';
            
            if (segments.length > 0) {
                const lastSegment = segments[segments.length - 1];
                // è§£ææœ€åä¸€ä¸ªæ®µè½çš„ç»“æŸæ—¶é—´
                const lastEndTime = lastSegment.end_time;
                const [hours, minutes, seconds] = lastEndTime.split(':');
                const [secs, ms] = seconds.split(',');
                
                // è®¡ç®—æ–°çš„å¼€å§‹æ—¶é—´ï¼ˆåœ¨æœ€åä¸€ä¸ªæ®µè½ç»“æŸåï¼‰
                const totalSeconds = parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(secs) + parseInt(ms) / 1000;
                const newStartSeconds = totalSeconds + 0.5; // æ·»åŠ 0.5ç§’é—´éš”
                const newEndSeconds = newStartSeconds + 5; // é»˜è®¤5ç§’æ—¶é•¿
                
                newStartTime = formatTime(newStartSeconds);
                newEndTime = formatTime(newEndSeconds);
            }

            // åˆ›å»ºæ–°æ®µè½å¯¹è±¡
            const newSegment = {
                id: newSegmentId,
                index: segments.length + 1,
                start_time: newStartTime,
                end_time: newEndTime,
                speaker: 'SPEAKER_00',
                emotion: 'neutral',
                speed: 1.0,
                text: 'è¯·è¾“å…¥æ–‡æœ¬å†…å®¹',
                translated_text: '',
                audio_data: null,
                audio_duration: 0,
                audio_url: '',
                trace_id: '',
                updated_at: new Date().toISOString()
            };

            try {
                // é€šè¿‡APIæ·»åŠ æ®µè½
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/segment`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(newSegment)
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`æ·»åŠ æ–°æ®µè½: ${newSegmentId}`);
                    showToast('æ–°æ®µè½å·²æ·»åŠ ');
                    
                    // é‡æ–°åŠ è½½å½“å‰é¡µé¢ï¼Œä¿æŒåˆ†é¡µ
                    await loadSubtitleSegments();
                } else {
                    showToast('æ·»åŠ æ®µè½å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('æ·»åŠ æ®µè½å¤±è´¥:', error);
                showToast('æ·»åŠ æ®µè½å¤±è´¥: ' + error.message);
            }
        }

        // åœ¨æŒ‡å®šä½ç½®æ’å…¥æ–°æ®µè½
        async function insertAfterSegment(segmentId) {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }

            // æ ¹æ®segmentIdæ‰¾åˆ°å¯¹åº”çš„æ®µè½å’Œç´¢å¼•
            const afterIndex = segments.findIndex(seg => seg.id === segmentId);
            if (afterIndex === -1) {
                showToast('æ‰¾ä¸åˆ°ç›®æ ‡æ®µè½');
                return;
            }
            

            // ç”Ÿæˆæ–°çš„æ®µè½ID
            const newSegmentId = 'segment_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // è®¡ç®—æ’å…¥ä½ç½®çš„æ—¶é—´æˆ³
            const currentSegment = segments[afterIndex];
            const nextSegment = segments[afterIndex + 1];
            
            let newStartTime, newEndTime;
            
            if (nextSegment) {
                // åœ¨ä¸¤ä¸ªæ®µè½ä¹‹é—´æ’å…¥
                const currentEndTime = currentSegment.end_time;
                const nextStartTime = nextSegment.start_time;
                
                
                // è®¡ç®—ä¸­é—´æ—¶é—´ - æ”¯æŒä¸¤ç§æ—¶é—´æ ¼å¼ï¼šHH:MM:SS,mmm å’Œ HH:MM:SS.mmm
                const [hours1, minutes1, seconds1] = currentEndTime.split(':');
                const [secs1, ms1] = seconds1.includes(',') ? seconds1.split(',') : seconds1.split('.');
                const currentEndSeconds = parseInt(hours1) * 3600 + parseInt(minutes1) * 60 + parseInt(secs1) + parseInt(ms1) / 1000;
                
                const [hours2, minutes2, seconds2] = nextStartTime.split(':');
                const [secs2, ms2] = seconds2.includes(',') ? seconds2.split(',') : seconds2.split('.');
                const nextStartSeconds = parseInt(hours2) * 3600 + parseInt(minutes2) * 60 + parseInt(secs2) + parseInt(ms2) / 1000;
                
                const middleTime = (currentEndSeconds + nextStartSeconds) / 2;
                const newStartSeconds = middleTime - 2.5; // æ–°æ®µè½å¼€å§‹æ—¶é—´
                const newEndSeconds = middleTime + 2.5; // æ–°æ®µè½ç»“æŸæ—¶é—´
                
                newStartTime = formatTime(newStartSeconds);
                newEndTime = formatTime(newEndSeconds);
            } else {
                // åœ¨æœ€åä¸€ä¸ªæ®µè½ä¹‹åæ’å…¥
                const lastEndTime = currentSegment.end_time;
                const [hours, minutes, seconds] = lastEndTime.split(':');
                const [secs, ms] = seconds.includes(',') ? seconds.split(',') : seconds.split('.');
                
                const totalSeconds = parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(secs) + parseInt(ms) / 1000;
                const newStartSeconds = totalSeconds + 0.5;
                const newEndSeconds = newStartSeconds + 5;
                
                newStartTime = formatTime(newStartSeconds);
                newEndTime = formatTime(newEndSeconds);
            }

            // åˆ›å»ºæ–°æ®µè½å¯¹è±¡
            const newSegment = {
                id: newSegmentId,
                index: afterIndex + 2, // ä¸´æ—¶åºå·ï¼Œåé¢ä¼šæ›´æ–°
                start_time: newStartTime,
                end_time: newEndTime,
                speaker: 'SPEAKER_00',
                emotion: 'neutral',
                speed: 1.0,
                text: 'è¯·è¾“å…¥æ–‡æœ¬å†…å®¹',
                translated_text: '',
                audio_data: null,
                audio_duration: 0,
                audio_url: '',
                trace_id: '',
                updated_at: new Date().toISOString(),
                insert_after_segment_id: segmentId  // ä½¿ç”¨æ®µè½IDè€Œéç´¢å¼•
            };

            try {
                // é€šè¿‡APIæ·»åŠ æ®µè½
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/segment`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(newSegment)
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`åœ¨æ®µè½ ${currentSegment.index} åæ’å…¥æ–°æ®µè½: ${newSegmentId}`);
                    showToast(`æ–°æ®µè½å·²æ’å…¥åˆ°æ®µè½ ${currentSegment.index} ä¹‹å`);
                    
                    // é‡æ–°åŠ è½½å½“å‰é¡µé¢ï¼Œä¿æŒåˆ†é¡µ
                    await loadSubtitleSegments();
                } else {
                    showToast('æ’å…¥æ®µè½å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('æ’å…¥æ®µè½å¤±è´¥:', error);
                showToast('æ’å…¥æ®µè½å¤±è´¥: ' + error.message);
            }
        }

        // åˆ é™¤æ®µè½
        async function deleteSegment(segmentId) {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }

            const segmentIndex = segments.findIndex(s => s.id === segmentId);
            if (segmentIndex === -1) {
                showToast('æ‰¾ä¸åˆ°æŒ‡å®šçš„æ®µè½');
                return;
            }

            // ç¡®è®¤åˆ é™¤
            if (!confirm(`ç¡®å®šè¦åˆ é™¤æ®µè½ ${segments[segmentIndex].index} å—ï¼Ÿ`)) {
                return;
            }

            try {
                // é€šè¿‡APIåˆ é™¤æ®µè½
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/segment/${segmentId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`åˆ é™¤æ®µè½: ${segmentId}`);
                    showToast('æ®µè½å·²åˆ é™¤');
                    
                    // é‡æ–°åŠ è½½å½“å‰é¡µé¢ï¼Œä¿æŒåˆ†é¡µ
                    await loadSubtitleSegments();
                } else {
                    showToast('åˆ é™¤æ®µè½å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('åˆ é™¤æ®µè½å¤±è´¥:', error);
                showToast('åˆ é™¤æ®µè½å¤±è´¥: ' + error.message);
            }
        }

        // æ›´æ–°æ®µè½åºå·
        function updateSegmentIndexes() {
            segments.forEach((segment, index) => {
                segment.index = index + 1;
            });
        }

        // æ ¼å¼åŒ–æ—¶é—´å‡½æ•°
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
        }

        // è·å–voiceMappingçš„å‡½æ•°
        function getVoiceMapping() {
            const mapping = {};
            
            // ä»æ–°çš„HTMLç»“æ„ä¸­è·å–é»˜è®¤è¯­éŸ³é…ç½®
            const speakers = ['SPEAKER_00', 'SPEAKER_01', 'SPEAKER_02', 'SPEAKER_03', 'SPEAKER_04', 'SPEAKER_05'];
            
            speakers.forEach(speaker => {
                const elementId = `speaker${speaker.slice(-2)}Voice`;
                const selectElement = document.getElementById(elementId);
                
                if (selectElement) {
                    const voice = selectElement.value;
                    if (voice) {
                        mapping[speaker] = voice;
                    }
                }
            });

            // æ·»åŠ è‡ªå®šä¹‰è§’è‰²è¯­éŸ³é…ç½®
            const customInputs = document.querySelectorAll('[id^="customSpeaker_"]');
            customInputs.forEach(input => {
                const speakerName = input.dataset.speakerName;
                const voiceId = input.value;
                if (speakerName && voiceId) {
                    mapping[speakerName] = voiceId;
                }
            });

            return mapping;
        }

        // éŸ³é¢‘æ’­æ”¾å‡½æ•°
        function playAudio(segmentId) {
            const segment = segments.find(s => s.id === segmentId);
            if (!segment || !segment.audio_url || segment.audio_url === '') {
                showToast('æ²¡æœ‰å¯æ’­æ”¾çš„éŸ³é¢‘');
                return;
            }

            try {
                const audio = new Audio(segment.audio_url);
                audio.play().catch(error => {
                    console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                    showToast('éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + error.message);
                });
            } catch (error) {
                console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                showToast('éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + error.message);
            }
        }

        // æ‰¹é‡ç”ŸæˆTTS
        async function batchGenerateTTS() {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }
            
            const groupId = document.getElementById('groupId').value;
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('voiceModel').value;
            const language = document.getElementById('language').value;
            const voiceMapping = getVoiceMapping();
            
            if (!groupId || !apiKey) {
                addLog('é…ç½®é”™è¯¯: ç¼ºå°‘Group IDæˆ–API Key');
                showToast('è¯·å…ˆé…ç½®Group IDå’ŒAPI Key');
                return;
            }
            
            if (Object.keys(voiceMapping).length === 0) {
                addLog('é…ç½®é”™è¯¯: ç¼ºå°‘è§’è‰²è¯­éŸ³æ˜ å°„');
                showToast('è¯·å…ˆé…ç½®è§’è‰²è¯­éŸ³æ˜ å°„');
                return;
            }
            
            addLog(`å¼€å§‹æ‰¹é‡ç”ŸæˆTTS: é¡¹ç›®${currentSubtitleProject.id}, æ€»æ®µè½æ•°=${segments.length}`);
            
            // ç¦ç”¨æŒ‰é’®
            const batchTTSBtn = document.getElementById('batchTTSBtn');
            const originalText = batchTTSBtn.innerHTML;
            batchTTSBtn.disabled = true;
            batchTTSBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>æ­£åœ¨ç”Ÿæˆ...';
            
            // å¼€å§‹å®æ—¶æ—¥å¿—æ›´æ–°
            const clientId = generateClientId();
            currentOperationClientId = clientId;
            let logUpdateInterval;
            
            try {
                addLog(`è°ƒç”¨æ‰¹é‡TTS API: æ¨¡å‹=${model}, è¯­è¨€=${language}`);
                showToast('å¼€å§‹æ‰¹é‡ç”ŸæˆTTS...');
                
                // å¼€å§‹å®æ—¶æ—¥å¿—æ›´æ–°
                startRealTimeLogUpdates(clientId);
                
                const formData = new FormData();
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('apiEndpoint', document.getElementById('apiEndpoint').value);
                formData.append('model', model);
                formData.append('language', language);
                formData.append('voiceMapping', JSON.stringify(voiceMapping));
                formData.append('clientId', clientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/batch-generate-tts`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
                stopRealTimeLogUpdates();
                
                if (result.success) {
                    const stats = result.statistics || {};
                    const total = stats.total_segments || result.updated_segments.length;
                    const successful = stats.successful_segments || result.updated_segments.length;
                    const failed = stats.failed_segments || 0;
                    const accelerated = stats.accelerated_segments || 0;
                    const maxSpeed = stats.max_speed_segments || 0;
                    
                    let message;
                    if (result.interrupted) {
                        message = `æ‰¹é‡TTSè¢«ä¸­æ–­ï¼å·²å¤„ç† ${successful}/${total} ä¸ªæ®µè½`;
                        addLog(`æ‰¹é‡TTSç”Ÿæˆè¢«ä¸­æ–­: ${successful}/${total}ä¸ªæ®µè½, å·²ä¿å­˜è¿›åº¦`);
                        showToast(message);
                    } else {
                        message = `æ‰¹é‡TTSç”Ÿæˆå®Œæˆï¼æˆåŠŸå¤„ç† ${successful}/${total} ä¸ªæ®µè½`;
                        if (failed > 0) {
                            message += `ï¼Œå¤±è´¥ ${failed} ä¸ª`;
                        }
                        if (accelerated > 0) {
                            message += `ï¼ŒåŠ é€Ÿ ${accelerated} ä¸ª`;
                        }
                        if (maxSpeed > 0) {
                            message += `ï¼Œæœ€å¤§åŠ é€Ÿ ${maxSpeed} ä¸ª`;
                        }
                        
                        addLog(`æ‰¹é‡TTSç”ŸæˆæˆåŠŸ: ${successful}/${total}ä¸ªæ®µè½`);
                        if (failed > 0) {
                            addLog(`å¤±è´¥æ®µè½: ${failed}ä¸ª`);
                        }
                        if (accelerated > 0) {
                            addLog(`åŠ é€Ÿæ®µè½: ${accelerated}ä¸ª`);
                        }
                        if (maxSpeed > 0) {
                            addLog(`æœ€å¤§åŠ é€Ÿæ®µè½: ${maxSpeed}ä¸ª`);
                        }
                        
                        // æ˜¾ç¤ºé€Ÿåº¦è°ƒæ•´è¯¦æƒ…
                        if (result.speed_adjustments && result.speed_adjustments.length > 0) {
                            addLog(`é€Ÿåº¦è°ƒæ•´è¯¦æƒ…:`);
                            result.speed_adjustments.forEach(adjustment => {
                                addLog(`  ${adjustment}`);
                            });
                        }
                        
                        showToast(message);
                    }
                    
                    // é‡æ–°åŠ è½½å­—å¹•æ®µè½ä»¥æ›´æ–°æ’­æ”¾æŒ‰é’®å’Œtrace_id
                    loadSubtitleSegments();
                } else {
                    addLog(`æ‰¹é‡TTSç”Ÿæˆå¤±è´¥: ${result.message}`);
                    showToast('æ‰¹é‡TTSç”Ÿæˆå¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('æ‰¹é‡TTSç”Ÿæˆå¤±è´¥:', error);
                addLog(`æ‰¹é‡TTSç”Ÿæˆå¤±è´¥: ${error.message}`);
                showToast('æ‰¹é‡TTSç”Ÿæˆå¤±è´¥: ' + error.message);
            } finally {
                // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
                stopRealTimeLogUpdates();
                // æ¢å¤æŒ‰é’®ï¼Œæ¸…é™¤å®¢æˆ·ç«¯ID
                batchTTSBtn.disabled = false;
                batchTTSBtn.innerHTML = originalText;
                currentOperationClientId = null;
            }
        }
        
        // å¼€å§‹å®æ—¶æ—¥å¿—æ›´æ–°
        function startRealTimeLogUpdates(clientId) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (window.logUpdateTimer) {
                clearInterval(window.logUpdateTimer);
            }
            
            // è®¾ç½®å®šæ—¶å™¨ï¼Œæ¯2ç§’æ£€æŸ¥ä¸€æ¬¡æ—¥å¿—æ›´æ–°
            window.logUpdateTimer = setInterval(async () => {
                try {
                    const response = await fetch(`/api/logs/${clientId}`);
                    
                    if (response.ok) {
                        const logs = await response.json();
                        
                        if (logs && logs.length > 0) {
                            // æ·»åŠ æ–°çš„æ—¥å¿—æ¡ç›®
                            logs.forEach(log => {
                                if (log.message && !window.processedLogs.has(log.id)) {
                                    // ç»„åˆmessageå’Œdetails
                                    let logText = log.message;
                                    if (log.details && log.details.trim()) {
                                        logText += `: ${log.details}`;
                                    }
                                    
                                    // è°ƒè¯•ä¿¡æ¯ - ç‰¹åˆ«å…³æ³¨ratioä¿¡æ¯
                                    if (log.message.includes('æ—¶é•¿æ¯”ä¾‹')) {
                                        console.log('DEBUG: æ¥æ”¶åˆ°ratioæ—¥å¿—', log);
                                    }
                                    
                                    addLog(logText);
                                    window.processedLogs.add(log.id);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error('è·å–æ—¥å¿—å¤±è´¥:', error);
                }
            }, 2000);
            
            // åˆå§‹åŒ–å·²å¤„ç†æ—¥å¿—é›†åˆ
            if (!window.processedLogs) {
                window.processedLogs = new Set();
            }
        }
        
        // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
        function stopRealTimeLogUpdates() {
            if (window.logUpdateTimer) {
                clearInterval(window.logUpdateTimer);
                window.logUpdateTimer = null;
            }
            // æ¸…ç©ºå·²å¤„ç†æ—¥å¿—é›†åˆ
            if (window.processedLogs) {
                window.processedLogs.clear();
            }
        }

        // æ‹¼æ¥éŸ³é¢‘è¾“å‡º
        async function mergeAudio() {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰éŸ³é¢‘æ•°æ®
            const segmentsWithAudio = segments.filter(s => s.audio_url && s.audio_url !== '');
            if (segmentsWithAudio.length === 0) {
                addLog('åˆå¹¶å¤±è´¥: æ²¡æœ‰å¯ç”¨çš„éŸ³é¢‘æ•°æ®');
                showToast('æ²¡æœ‰å¯ç”¨çš„éŸ³é¢‘æ•°æ®ï¼Œè¯·å…ˆç”ŸæˆTTS');
                return;
            }
            
                            addLog(`å¼€å§‹æ‹¼æ¥éŸ³é¢‘: é¡¹ç›®${currentSubtitleProject.id}, å¯ç”¨éŸ³é¢‘æ®µè½=${segmentsWithAudio.length}`);
            
            // ç¦ç”¨æŒ‰é’®
            const mergeBtn = document.getElementById('mergeBtn');
            const originalText = mergeBtn.innerHTML;
            mergeBtn.disabled = true;
            mergeBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>æ­£åœ¨åˆå¹¶...';
            
            try {
                addLog('è°ƒç”¨æ‹¼æ¥éŸ³é¢‘API...');
                showToast('å¼€å§‹æ‹¼æ¥éŸ³é¢‘...');
                
                const formData = new FormData();
                const clientId = generateClientId();
                currentOperationClientId = clientId;
                formData.append('clientId', clientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/merge-audio`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog(`éŸ³é¢‘æ‹¼æ¥æˆåŠŸ: è¾“å‡ºæ–‡ä»¶=${result.output_file}, æ®µè½æ•°=${result.segments_count}`);
                    showToast(`éŸ³é¢‘æ‹¼æ¥å®Œæˆï¼è¾“å‡ºæ–‡ä»¶: ${result.output_file}`);
                    
                    // æ˜¾ç¤ºåˆå¹¶ç»“æœåœ¨å›ºå®šä½ç½®
                    showMergeResult(result);
                    
                } else {
                    addLog(`éŸ³é¢‘æ‹¼æ¥å¤±è´¥: ${result.message}`);
                    showToast('éŸ³é¢‘æ‹¼æ¥å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('éŸ³é¢‘æ‹¼æ¥å¤±è´¥:', error);
                addLog(`éŸ³é¢‘æ‹¼æ¥å¤±è´¥: ${error.message}`);
                showToast('éŸ³é¢‘æ‹¼æ¥å¤±è´¥: ' + error.message);
            } finally {
                // æ¢å¤æŒ‰é’®ï¼Œæ¸…é™¤å®¢æˆ·ç«¯ID
                mergeBtn.disabled = false;
                mergeBtn.innerHTML = originalText;
                currentOperationClientId = null;
            }
        }

        // æ˜¾ç¤ºåˆå¹¶ç»“æœ
        function showMergeResult(result) {
            const mergeResultCard = document.getElementById('mergeResultCard');
            const mergeDownloadBtn = document.getElementById('mergeDownloadBtn');
            const audioStatus = document.getElementById('audioStatus');
            const playBtn = document.getElementById('mergePlayBtn');
            const pauseBtn = document.getElementById('mergePauseBtn');
            
            // æ£€æŸ¥å¿…è¦çš„DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!mergeResultCard) {
                console.error('mergeResultCard not found');
                return;
            }
            
            // è®¾ç½®ä¸‹è½½é“¾æ¥ï¼ˆå¦‚æœå…ƒç´ å­˜åœ¨ï¼‰
            if (mergeDownloadBtn) {
                mergeDownloadBtn.href = result.download_url;
                mergeDownloadBtn.download = result.output_file;
            }
            
            // å¯ç”¨æ’­æ”¾å™¨ï¼ˆå¦‚æœå…ƒç´ å­˜åœ¨ï¼‰
            if (playBtn) {
                playBtn.disabled = false;
            }
            if (pauseBtn) {
                pauseBtn.disabled = false;
            }
            
            // å¯ç”¨ä¸‹è½½æŒ‰é’®ï¼ˆå¦‚æœå…ƒç´ å­˜åœ¨ï¼‰
            const downloadBtn = document.getElementById('downloadAudioBtn');
            if (downloadBtn) {
                downloadBtn.disabled = false;
            }
            
            // æ›´æ–°çŠ¶æ€æç¤ºï¼ˆå¦‚æœå…ƒç´ å­˜åœ¨ï¼‰
            if (audioStatus) {
                audioStatus.innerHTML = '';
            }
            
            // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
            initAudioPlayer(result.download_url);
        }

        // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
        let currentAudio = null;
        let audioUpdateTimer = null;
        let audioContext = null;
        let audioAnalyser = null;
        let waveformData = null;

        function initAudioPlayer(audioUrl) {
            // æ¸…ç†ä¹‹å‰çš„éŸ³é¢‘
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (audioUpdateTimer) {
                clearInterval(audioUpdateTimer);
            }
            
            // åˆ›å»ºæ–°çš„éŸ³é¢‘å¯¹è±¡
            currentAudio = new Audio(audioUrl);
            
            // è·å–æ’­æ”¾å™¨å…ƒç´ 
            const playBtn = document.getElementById('mergePlayBtn');
            const pauseBtn = document.getElementById('mergePauseBtn');
            const progressBar = document.getElementById('audioProgress');
            const currentTimeSpan = document.getElementById('currentTime');
            const totalTimeSpan = document.getElementById('totalTime');
            const volumeSlider = document.getElementById('audioVolume');
            const speedSelect = document.getElementById('audioSpeed');
            const waveformCanvas = document.getElementById('audioWaveform');
            
            // æ£€æŸ¥å¿…è¦çš„DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!playBtn || !pauseBtn || !progressBar || !currentTimeSpan || !totalTimeSpan || !waveformCanvas) {
                console.error('Some audio player elements not found');
                return;
            }
            
            // ç”Ÿæˆæ³¢å½¢
            generateWaveform(audioUrl, waveformCanvas);
            
            // æ³¢å½¢ç‚¹å‡»äº‹ä»¶
            waveformCanvas.onclick = (event) => {
                if (!currentAudio) return;
                
                const rect = waveformCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const progress = x / rect.width;
                const seekTime = progress * currentAudio.duration;
                
                currentAudio.currentTime = seekTime;
                updateWaveformPosition(progress);
                
                // æ›´æ–°è¿›åº¦æ¡
                progressBar.value = progress * 100;
                currentTimeSpan.textContent = formatTime(seekTime);
            };
            
            // æ’­æ”¾æŒ‰é’®äº‹ä»¶
            playBtn.onclick = () => {
                currentAudio.play().then(() => {
                    playBtn.style.display = 'none';
                    pauseBtn.style.display = 'inline-block';
                    startProgressUpdate();
                    startWaveformUpdate();
                }).catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    showToast('æ’­æ”¾å¤±è´¥: ' + error.message);
                });
            };
            
            // æš‚åœæŒ‰é’®äº‹ä»¶
            pauseBtn.onclick = () => {
                currentAudio.pause();
                playBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopProgressUpdate();
                stopWaveformUpdate();
            };
            
            // è¿›åº¦æ¡äº‹ä»¶
            progressBar.oninput = () => {
                if (!currentAudio) return;
                
                const seekTime = (progressBar.value / 100) * currentAudio.duration;
                currentAudio.currentTime = seekTime;
                currentTimeSpan.textContent = formatTime(seekTime);
                updateWaveformPosition(progressBar.value / 100);
            };
            
            // éŸ³é¢‘åŠ è½½å®Œæˆäº‹ä»¶
            currentAudio.onloadedmetadata = () => {
                totalTimeSpan.textContent = formatTime(currentAudio.duration);
                progressBar.max = 100;
            };
            
            // éŸ³é¢‘æ’­æ”¾äº‹ä»¶
            currentAudio.onplay = () => {
                startProgressUpdate();
            };
            
            // éŸ³é¢‘æš‚åœäº‹ä»¶
            currentAudio.onpause = () => {
                stopProgressUpdate();
            };
            
            // éŸ³é¢‘ç»“æŸäº‹ä»¶
            currentAudio.onended = () => {
                playBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopProgressUpdate();
                stopWaveformUpdate();
                progressBar.value = 0;
                currentTimeSpan.textContent = '00:00';
                updateWaveformPosition(0);
            };
        }
        
        // å¼€å§‹è¿›åº¦æ›´æ–°
        function startProgressUpdate() {
            audioUpdateTimer = setInterval(() => {
                if (currentAudio && !currentAudio.paused) {
                    const progressBar = document.getElementById('audioProgress');
                    const currentTimeSpan = document.getElementById('currentTime');
                    
                    if (progressBar && currentTimeSpan) {
                        const progress = (currentAudio.currentTime / currentAudio.duration) * 100;
                        progressBar.value = progress;
                        currentTimeSpan.textContent = formatTime(currentAudio.currentTime);
                        
                        // æ›´æ–°æ³¢å½¢æ’­æ”¾ä½ç½®
                        updateWaveformPosition(currentAudio.currentTime / currentAudio.duration);
                    }
                }
            }, 100);
        }
        
        // åœæ­¢è¿›åº¦æ›´æ–°
        function stopProgressUpdate() {
            if (audioUpdateTimer) {
                clearInterval(audioUpdateTimer);
                audioUpdateTimer = null;
            }
        }
        
        // æ ¼å¼åŒ–æ—¶é—´
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // æ’­æ”¾åˆå¹¶éŸ³é¢‘ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œç”¨äºå…¼å®¹ï¼‰
        function playMergedAudio(audioUrl) {
            try {
                const audio = new Audio(audioUrl);
                audio.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    showToast('æ’­æ”¾å¤±è´¥: ' + error.message);
                });
            } catch (error) {
                console.error('æ’­æ”¾å¤±è´¥:', error);
                showToast('æ’­æ”¾å¤±è´¥: ' + error.message);
            }
        }

        // åˆ†é¡µæŒ‰é’®äº‹ä»¶å¤„ç†
        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                loadSubtitleSegments();
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            currentPage++;
            loadSubtitleSegments();
        });


        // æ£€æŸ¥æ˜¯å¦æœ‰å·²ä¿å­˜çš„é¡¹ç›®ï¼Œå¹¶è¿”å›é¡¹ç›®åˆ—è¡¨
        async function checkForSavedProjects() {
            try {
                console.log('æ­£åœ¨æ£€æŸ¥å·²ä¿å­˜çš„é¡¹ç›®...');
                const response = await fetch('/api/projects');
                console.log('é¡¹ç›®APIå“åº”çŠ¶æ€:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('é¡¹ç›®APIå“åº”æ•°æ®:', data);
                    
                    if (data.projects && data.projects.length > 0) {
                        console.log(`å‘ç° ${data.projects.length} ä¸ªé¡¹ç›®`);
                        return data.projects;
                    } else {
                        console.log('æ²¡æœ‰å‘ç°é¡¹ç›®');
                    }
                } else {
                    console.log('é¡¹ç›®APIè¯·æ±‚å¤±è´¥:', response.status);
                }
            } catch (error) {
                console.log('æ£€æŸ¥å·²ä¿å­˜é¡¹ç›®å¤±è´¥:', error);
            }
            return null;
        }

        // åŠ è½½æŒ‡å®šé¡¹ç›®çš„æ®µè½
        async function loadProjectSegments(projectId) {
            try {
                // è®¾ç½®å½“å‰é¡¹ç›®ä¿¡æ¯
                currentSubtitleProject = { id: projectId };
                currentPage = 1;
                
                // ä½¿ç”¨ç°æœ‰çš„åŠ è½½å‡½æ•°
                await loadSubtitleSegments();
                return true;
            } catch (error) {
                console.log('åŠ è½½é¡¹ç›®æ®µè½å¤±è´¥:', error);
                return false;
            }
        }

        // è‡ªåŠ¨åŠ è½½ç¤ºä¾‹SRTæ–‡ä»¶
        async function loadSampleSrt() {
            try {
                // è·å–ç¤ºä¾‹SRTæ–‡ä»¶
                const response = await fetch('/samples/double_life_English.srt');
                if (!response.ok) {
                    console.log('ç¤ºä¾‹æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®');
                    return;
                }
                
                const fileContent = await response.text();
                
                // åˆ›å»ºæ–‡ä»¶å¯¹è±¡
                const blob = new Blob([fileContent], { type: 'text/plain' });
                const file = new File([blob], 'double_life_English.srt', { type: 'text/plain' });
                
                // è°ƒç”¨ç°æœ‰çš„ä¸Šä¼ å¤„ç†å‡½æ•°
                await handleQuickSrtUpload(file);
                
                console.log('ç¤ºä¾‹SRTæ–‡ä»¶å·²è‡ªåŠ¨åŠ è½½');
                showToast('âœ¨ å·²è‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ–‡ä»¶ï¼šåŒé‡ç”Ÿæ´»è‹±æ–‡å­—å¹•');
            } catch (error) {
                console.log('è‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ–‡ä»¶å¤±è´¥:', error);
                
                // å¦‚æœè‡ªåŠ¨åŠ è½½å¤±è´¥ï¼Œæ¢å¤é»˜è®¤ç•Œé¢
                const container = document.getElementById('subtitleEditor');
                container.innerHTML = `
                    <div class="text-center py-5" style="color: var(--pink-400);">
                        <i class="bi bi-file-earmark-text fs-1"></i>
                        <p class="mt-2">ä¸Šä¼ SRTæ–‡ä»¶å¼€å§‹ç¼–è¾‘</p>
                    </div>
                `;
            }
        }

        // æ·»åŠ æ—¥å¿—åˆ°æ—¥å¿—å®¹å™¨
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            if (!logContainer) return;
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry mb-1 p-1';
            logEntry.textContent = message;  // ç›´æ¥ä½¿ç”¨textContentï¼Œä¸åšä»»ä½•HTMLå¤„ç†
            
            // å¦‚æœæ˜¯ç¬¬ä¸€æ¡æ—¥å¿—ï¼Œæ¸…é™¤åˆå§‹æç¤º
            if (logContainer.querySelector('.text-center')) {
                logContainer.innerHTML = '';
            }
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLogs() {
            const logContainer = document.getElementById('logContainer');
            if (logContainer) {
                logContainer.innerHTML = '';
            }
        }

        // é…ç½®ç®¡ç†åŠŸèƒ½
        const CREDENTIALS_KEY = 'minimax_tts_credentials';
        const CONFIG_KEY = 'minimax_tts_config';
        
        
        function autoSaveCredentials() {
            const groupId = document.getElementById('groupId').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (groupId && apiKey) {
                const credentials = {
                    groupId: groupId,
                    apiKey: apiKey,
                    savedAt: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem(CREDENTIALS_KEY, JSON.stringify(credentials));
                } catch (error) {
                    console.error('ä¿å­˜å‡­æ®å¤±è´¥:', error);
                }
            }
        }

        // ä¿å­˜æ‰€æœ‰é…ç½®å‚æ•°
        function saveAllConfig() {
            const config = {
                // è¯­éŸ³æ¨¡å‹
                voiceModel: document.getElementById('voiceModel').value,
                // è¯­è¨€é€‰æ‹©
                language: document.getElementById('language').value,
                // è¯´è¯äººè¯­éŸ³é…ç½®
                speaker00Voice: document.getElementById('speaker00Voice').value,
                speaker01Voice: document.getElementById('speaker01Voice').value,
                speaker02Voice: document.getElementById('speaker02Voice').value,
                speaker03Voice: document.getElementById('speaker03Voice').value,
                speaker04Voice: document.getElementById('speaker04Voice').value,
                speaker05Voice: document.getElementById('speaker05Voice').value,
                // ä¿å­˜æ—¶é—´æˆ³
                savedAt: new Date().toISOString()
            };
            
            try {
                localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
                console.log('é…ç½®å·²è‡ªåŠ¨ä¿å­˜, è¯­è¨€:', config.language);
            } catch (error) {
                console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
            }
        }

        // åŠ è½½æ‰€æœ‰é…ç½®å‚æ•°
        function loadAllConfig() {
            try {
                const saved = localStorage.getItem(CONFIG_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    
                    // æ¢å¤è¯­éŸ³æ¨¡å‹
                    if (config.voiceModel) {
                        document.getElementById('voiceModel').value = config.voiceModel;
                    }
                    
                    // æ¢å¤è¯­è¨€é€‰æ‹©
                    if (config.language) {
                        document.getElementById('language').value = config.language;
                        console.log('å·²æ¢å¤è¯­è¨€è®¾ç½®ä¸º:', config.language);
                    }
                    
                    // æ¢å¤è¯´è¯äººè¯­éŸ³é…ç½®
                    if (config.speaker00Voice) {
                        document.getElementById('speaker00Voice').value = config.speaker00Voice;
                    }
                    if (config.speaker01Voice) {
                        document.getElementById('speaker01Voice').value = config.speaker01Voice;
                    }
                    if (config.speaker02Voice) {
                        document.getElementById('speaker02Voice').value = config.speaker02Voice;
                    }
                    if (config.speaker03Voice) {
                        document.getElementById('speaker03Voice').value = config.speaker03Voice;
                    }
                    if (config.speaker04Voice) {
                        document.getElementById('speaker04Voice').value = config.speaker04Voice;
                    }
                    if (config.speaker05Voice) {
                        document.getElementById('speaker05Voice').value = config.speaker05Voice;
                    }
                    
                    console.log('é…ç½®å·²è‡ªåŠ¨åŠ è½½');
                    return true;
                } else {
                    // æ²¡æœ‰ä¿å­˜çš„é…ç½®æ—¶ï¼Œè®¾ç½®é»˜è®¤è¯­è¨€ä¸ºä¸­æ–‡
                    document.getElementById('language').value = 'Chinese';
                    console.log('è®¾ç½®é»˜è®¤è¯­è¨€ä¸ºä¸­æ–‡');
                }
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
                // å‡ºé”™æ—¶ä¹Ÿè®¾ç½®é»˜è®¤è¯­è¨€
                document.getElementById('language').value = 'Chinese';
            }
            return false;
        }

        // æµ‹è¯•å‡½æ•° - æ‰‹åŠ¨æ£€æŸ¥é…ç½®
        function testConfig() {
            console.log('=== é…ç½®æµ‹è¯• ===');
            const saved = localStorage.getItem(CONFIG_KEY);
            console.log('localStorageä¸­çš„é…ç½®:', saved);
            if (saved) {
                const config = JSON.parse(saved);
                console.log('è§£æåçš„é…ç½®:', config);
                console.log('ä¿å­˜çš„è¯­è¨€:', config.language);
            }
            console.log('å½“å‰é¡µé¢è¯­è¨€é€‰æ‹©å™¨çš„å€¼:', document.getElementById('language').value);
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ–‡ä»¶
        document.addEventListener('DOMContentLoaded', async () => {
            // åŠ è½½HTMLç»„ä»¶ - Phase 2ç»„ä»¶åŒ–
            try {
                await componentLoader.loadBatch([
                    { path: 'sections/audio-player.html', target: '#audioPlayerSection' },
                    { path: 'sections/log-display.html', target: '#logDisplaySection' },
                    { path: 'widgets/project-panel.html', target: '#projectPanelSection' },
                    { path: 'widgets/batch-panel.html', target: '#batchPanelSection' },
                    { path: 'modals/add-speaker-modal.html', target: '#modalsSection' }
                ]);
                console.log('âœ… ç»„ä»¶åŠ è½½å®Œæˆ');
            } catch (error) {
                console.error('âŒ ç»„ä»¶åŠ è½½å¤±è´¥:', error);
            }
            
            // è§’è‰²é…ç½®ç°åœ¨åœ¨HTMLä¸­é™æ€å®šä¹‰ï¼Œæ— éœ€åŠ¨æ€åŠ è½½
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å·²ä¿å­˜çš„é¡¹ç›®ï¼Œå¦‚æœæœ‰åˆ™è‡ªåŠ¨åŠ è½½æœ€è¿‘çš„é¡¹ç›®
            const savedProjects = await checkForSavedProjects();
            if (!savedProjects) {
                // åªæœ‰åœ¨æ²¡æœ‰ä¿å­˜é¡¹ç›®æ—¶æ‰åŠ è½½ç¤ºä¾‹æ–‡ä»¶
                addLog('æœªå‘ç°ä¿å­˜çš„é¡¹ç›®ï¼ŒåŠ è½½ç¤ºä¾‹æ–‡ä»¶');
                loadSampleSrt();
            } else {
                // å¦‚æœæœ‰ä¿å­˜çš„é¡¹ç›®ï¼Œè‡ªåŠ¨åŠ è½½æœ€è¿‘çš„é¡¹ç›®
                addLog(`å‘ç° ${savedProjects.length} ä¸ªä¿å­˜çš„é¡¹ç›®ï¼Œæ­£åœ¨åŠ è½½æœ€è¿‘çš„é¡¹ç›®`);
                
                // æŒ‰æ›´æ–°æ—¶é—´æ’åºï¼Œè·å–æœ€è¿‘çš„é¡¹ç›®
                const latestProject = savedProjects.sort((a, b) => 
                    new Date(b.updated_at) - new Date(a.updated_at)
                )[0];
                
                addLog(`æ­£åœ¨åŠ è½½é¡¹ç›®: ${latestProject.filename}`);
                
                // åŠ è½½æœ€è¿‘é¡¹ç›®çš„æ®µè½
                const loadSuccess = await loadProjectSegments(latestProject.id);
                if (loadSuccess) {
                    addLog(`âœ… é¡¹ç›®åŠ è½½æˆåŠŸ: ${latestProject.filename}`);
                    
                    // è®¾ç½®å…¨å±€å½“å‰é¡¹ç›®IDï¼ˆå¦‚æœé¡µé¢ä¸­æœ‰è¿™ä¸ªå˜é‡çš„è¯ï¼‰
                    if (typeof window !== 'undefined') {
                        window.currentProjectId = latestProject.id;
                    }
                } else {
                    addLog('âŒ é¡¹ç›®åŠ è½½å¤±è´¥ï¼Œåˆ‡æ¢åˆ°ç¤ºä¾‹æ–‡ä»¶');
                    loadSampleSrt();
                }
            }
            
            // éšè—ç¿»è¯‘åŠŸèƒ½åŒºåŸŸ
            const translationSection = document.getElementById('translationSection');
            if (translationSection) {
                translationSection.style.display = 'none';
            }
            
            // è‡ªåŠ¨åŠ è½½ä¿å­˜çš„å‡­æ®
            try {
                const saved = localStorage.getItem(CREDENTIALS_KEY);
                if (saved) {
                    const credentials = JSON.parse(saved);
                    document.getElementById('groupId').value = credentials.groupId || '';
                    document.getElementById('apiKey').value = credentials.apiKey || '';
                }
            } catch (error) {
                console.error('åŠ è½½å‡­æ®å¤±è´¥:', error);
            }
            
            // è‡ªåŠ¨åŠ è½½ä¿å­˜çš„é…ç½®å‚æ•° - å»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMå®Œå…¨åŠ è½½
            setTimeout(() => {
                const configLoaded = loadAllConfig();
                addLog('é…ç½®åŠ è½½å®Œæˆï¼Œå½“å‰è¯­è¨€: ' + document.getElementById('language').value);
                if (configLoaded) {
                    addLog('å·²è‡ªåŠ¨åŠ è½½ä¿å­˜çš„é…ç½®å‚æ•°');
                }
            }, 100);
            
            // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨çŠ¶æ€
            initAudioPlayerState();
            
            // åˆå§‹åŒ–è‡ªå®šä¹‰è§’è‰²åŠŸèƒ½
            await loadCustomSpeakers();
            loadCustomSpeakersConfig();
            await updateSpeakerSelectors();
            
            // æ·»åŠ åˆå§‹æ—¥å¿—
            addLog('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
            addLog('è§’è‰²è¯­éŸ³é…ç½®å·²åŠ è½½');
            
            
            // è‡ªåŠ¨ä¿å­˜åŠŸèƒ½ - åœ¨è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹æ—¶è‡ªåŠ¨ä¿å­˜
            const groupIdInput = document.getElementById('groupId');
            const apiKeyInput = document.getElementById('apiKey');
            
            if (groupIdInput) {
                groupIdInput.addEventListener('blur', autoSaveCredentials);
            }
            if (apiKeyInput) {
                apiKeyInput.addEventListener('blur', autoSaveCredentials);
            }
            
            // é…ç½®å‚æ•°è‡ªåŠ¨ä¿å­˜ - ç›‘å¬æ‰€æœ‰é…ç½®è¾“å…¥æ¡†çš„å˜åŒ–
            const configElements = [
                'voiceModel',
                'language', 
                'speaker00Voice',
                'speaker01Voice',
                'speaker02Voice',
                'speaker03Voice',
                'speaker04Voice',
                'speaker05Voice'
            ];
            
            configElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    // ç›‘å¬å¤±å»ç„¦ç‚¹äº‹ä»¶ï¼ˆå¯¹inputç±»å‹ï¼‰
                    element.addEventListener('blur', saveAllConfig);
                    // ç›‘å¬é€‰æ‹©å˜åŒ–äº‹ä»¶ï¼ˆå¯¹selectç±»å‹ï¼‰
                    element.addEventListener('change', saveAllConfig);
                }
            });
            
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šæ’å…¥æ®µè½æŒ‰é’®ï¼Œç¡®ä¿åŠ¨æ€æ·»åŠ çš„æŒ‰é’®ä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ
            document.addEventListener('click', function(event) {
                if (event.target.closest('.insert-segment-btn')) {
                    const button = event.target.closest('.insert-segment-btn');
                    const segmentId = button.dataset.segmentId;
                    console.log('æ’å…¥æŒ‰é’®ç‚¹å‡»ï¼Œsegment ID:', segmentId);
                    addLog(`ğŸ”˜ ç‚¹å‡»æ’å…¥æŒ‰é’®ï¼Œç›®æ ‡æ®µè½ID: ${segmentId}`);
                    insertAfterSegment(segmentId);
                }
            });

            // ç»‘å®šæ¸…ç©ºæ—¥å¿—æŒ‰é’®
            const clearLogsBtn = document.getElementById('clearLogsBtn');
            if (clearLogsBtn) {
                clearLogsBtn.addEventListener('click', clearLogs);
            }
            
            // ç»‘å®šéŸ³é¢‘ä¸‹è½½æŒ‰é’®
            const downloadAudioBtn = document.getElementById('downloadAudioBtn');
            if (downloadAudioBtn) {
                downloadAudioBtn.addEventListener('click', () => {
                    const mergeDownloadBtn = document.getElementById('mergeDownloadBtn');
                    if (mergeDownloadBtn && mergeDownloadBtn.href !== '#') {
                        mergeDownloadBtn.click();
                    } else {
                        showToast('æ²¡æœ‰å¯ä¸‹è½½çš„éŸ³é¢‘æ–‡ä»¶');
                    }
                });
            }
            
            // ç»‘å®šå…³é—­åˆå¹¶ç»“æœæŒ‰é’®
            const clearMergeResultBtn = document.getElementById('clearMergeResultBtn');
            if (clearMergeResultBtn) {
                clearMergeResultBtn.addEventListener('click', () => {
                    const mergeResultCard = document.getElementById('mergeResultCard');
                    mergeResultCard.style.display = 'none';
                    
                    // åœæ­¢éŸ³é¢‘æ’­æ”¾
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio = null;
                    }
                    if (audioUpdateTimer) {
                        clearInterval(audioUpdateTimer);
                        audioUpdateTimer = null;
                    }
                });
            }
        });

        // å¢å¼ºçš„Toastå‡½æ•°ï¼Œæ”¯æŒä¸åŒç±»å‹çš„æ¶ˆæ¯
        function showToast(message, type = 'info') {
            const toastBody = document.getElementById('toastBody');
            const toastElement = document.getElementById('toast');
            
            if (!toastBody || !toastElement) {
                // å¦‚æœæ²¡æœ‰toastå…ƒç´ ï¼Œä½¿ç”¨alertä½œä¸ºåå¤‡
                alert(message);
                return;
            }
            
            toastBody.textContent = message;
            
            // æ ¹æ®ç±»å‹è®¾ç½®æ ·å¼
            toastElement.className = 'toast';
            switch(type) {
                case 'success':
                    toastElement.classList.add('bg-success', 'text-white');
                    break;
                case 'warning':
                    toastElement.classList.add('bg-warning', 'text-dark');
                    break;
                case 'error':
                    toastElement.classList.add('bg-danger', 'text-white');
                    break;
                default:
                    toastElement.classList.add('bg-info', 'text-white');
            }
            
            const toast = new bootstrap.Toast(toastElement);
            toast.show();
        }

        // æ‰¹é‡ç¿»è¯‘å‡½æ•°
        async function batchTranslate() {
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }
            
            // è·å–ç¿»è¯‘è¯­è¨€ï¼ˆä½¿ç”¨é…ç½®å‚æ•°åŒºçš„è¯­è¨€é€‰é¡¹ï¼‰
            const targetLanguage = document.getElementById('language').value;
            if (!targetLanguage) {
                showToast('è¯·é€‰æ‹©ç›®æ ‡è¯­è¨€');
                return;
            }
            
            // è·å–APIé…ç½®
            const groupId = document.getElementById('groupId').value;
            const apiKey = document.getElementById('apiKey').value;
            
            if (!groupId || !apiKey) {
                addLog('é…ç½®é”™è¯¯: ç¼ºå°‘Group IDæˆ–API Key');
                showToast('è¯·å…ˆé…ç½®Group IDå’ŒAPI Key');
                return;
            }
            
            // ç¦ç”¨æŒ‰é’®
            const batchTranslateBtn = document.getElementById('batchTranslateBtn');
            const originalText = batchTranslateBtn.innerHTML;
            batchTranslateBtn.disabled = true;
            batchTranslateBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>æ­£åœ¨ç¿»è¯‘...';
            
            try {
                addLog(`å¼€å§‹æ‰¹é‡ç¿»è¯‘: ç›®æ ‡è¯­è¨€=${targetLanguage}, æ®µè½æ•°=${segments.length}`);
                showToast('å¼€å§‹æ‰¹é‡ç¿»è¯‘...');
                
                // ç”Ÿæˆå®¢æˆ·ç«¯IDç”¨äºæ—¥å¿—
                const clientId = generateClientId();
                currentOperationClientId = clientId;
                
                // å¼€å§‹å®æ—¶æ—¥å¿—æ›´æ–°
                startRealTimeLogUpdates(clientId);
                
                const formData = new FormData();
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('apiEndpoint', document.getElementById('apiEndpoint').value);
                formData.append('target_language', targetLanguage);
                formData.append('clientId', clientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/batch-translate`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
                stopRealTimeLogUpdates();
                
                if (result.success) {
                    // å®‰å…¨åœ°è·å–ç»Ÿè®¡æ•°æ®
                    const stats = result.statistics || {};
                    const updatedSegments = result.updated_segments || [];
                    
                    // ä½¿ç”¨å¤šç§æ–¹å¼è·å–æ€»æ•°ï¼Œç¡®ä¿æœ‰å€¼
                    const total = stats.total_segments || result.total_segments || updatedSegments.length || segments.length;
                    const successful = stats.successful_segments || result.successful_translations || updatedSegments.length || 0;
                    const failed = stats.failed_segments || result.failed_translations || 0;
                    
                    if (result.interrupted) {
                        addLog(`æ‰¹é‡ç¿»è¯‘è¢«ä¸­æ–­: ${successful}/${total}ä¸ªæ®µè½, å·²ä¿å­˜è¿›åº¦`);
                        showToast(`æ‰¹é‡ç¿»è¯‘å·²ä¸­æ–­ï¼å·²å®Œæˆ ${successful}/${total} ä¸ªæ®µè½`);
                    } else {
                        addLog(`æ‰¹é‡ç¿»è¯‘æˆåŠŸ: ${successful}/${total}ä¸ªæ®µè½`);
                        if (failed > 0) {
                            addLog(`å¤±è´¥æ®µè½: ${failed}ä¸ª`);
                        }
                        showToast(`æ‰¹é‡ç¿»è¯‘å®Œæˆï¼æˆåŠŸå¤„ç† ${successful}/${total} ä¸ªæ®µè½`);
                    }
                    
                    // é‡æ–°åŠ è½½å­—å¹•æ®µè½ä»¥æ˜¾ç¤ºç¿»è¯‘ç»“æœ
                    loadSubtitleSegments();
                } else {
                    const errorMessage = result.message || 'æœªçŸ¥é”™è¯¯';
                    addLog(`æ‰¹é‡ç¿»è¯‘å¤±è´¥: ${errorMessage}`);
                    showToast('æ‰¹é‡ç¿»è¯‘å¤±è´¥: ' + errorMessage);
                }
            } catch (error) {
                console.error('æ‰¹é‡ç¿»è¯‘å¤±è´¥:', error);
                // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
                stopRealTimeLogUpdates();
                
                let errorMessage = 'æœªçŸ¥é”™è¯¯';
                if (error.message) {
                    errorMessage = error.message;
                } else if (typeof error === 'string') {
                    errorMessage = error;
                } else if (error.toString) {
                    errorMessage = error.toString();
                }
                
                addLog(`æ‰¹é‡ç¿»è¯‘å¤±è´¥: ${errorMessage}`);
                showToast('æ‰¹é‡ç¿»è¯‘å¤±è´¥: ' + errorMessage);
            } finally {
                // åœæ­¢å®æ—¶æ—¥å¿—æ›´æ–°
                stopRealTimeLogUpdates();
                // æ¢å¤æŒ‰é’®ï¼Œæ¸…é™¤å®¢æˆ·ç«¯ID
                batchTranslateBtn.disabled = false;
                batchTranslateBtn.innerHTML = originalText;
                currentOperationClientId = null;
            }
        }

        // å¼€å§‹å®æ—¶æ—¥å¿—æ›´æ–°
        
        // æ‰¹é‡é€‰æ‹©åŠŸèƒ½
        let selectedSegmentIds = new Set();

        // æ›´æ–°é€‰ä¸­æ•°é‡æ˜¾ç¤º
        function updateSelectedCount() {
            const checkboxes = document.querySelectorAll('.segment-checkbox:checked');
            const count = checkboxes.length;
            const selectedCountBadge = document.getElementById('selectedCount');
            const batchOperationSection = document.getElementById('batchOperationSection');
            const batchUpdateBtn = document.getElementById('batchUpdateBtn');
            
            // æ›´æ–°é€‰ä¸­çš„æ®µè½IDé›†åˆ
            selectedSegmentIds.clear();
            checkboxes.forEach(checkbox => {
                selectedSegmentIds.add(checkbox.getAttribute('data-segment-id'));
            });
            
            // æ›´æ–°æ˜¾ç¤º
            if (selectedCountBadge) {
                selectedCountBadge.textContent = `å·²é€‰æ‹©: ${count}`;
            }
            
            // æ˜¾ç¤ºæˆ–éšè—æ‰¹é‡æ“ä½œåŒºåŸŸ
            if (batchOperationSection) {
                batchOperationSection.style.display = count > 0 ? 'flex' : 'none';
            }
            
            // å¯ç”¨æˆ–ç¦ç”¨æ‰¹é‡æ›´æ–°æŒ‰é’®
            if (batchUpdateBtn) {
                batchUpdateBtn.disabled = count === 0;
            }
        }

        // å…¨é€‰åŠŸèƒ½
        function selectAllSegments() {
            const checkboxes = document.querySelectorAll('.segment-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateSelectedCount();
        }

        // æ¸…é™¤æ‰€æœ‰é€‰æ‹©
        function clearAllSelections() {
            const checkboxes = document.querySelectorAll('.segment-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateSelectedCount();
        }

        // æ‰¹é‡ä¿®æ”¹è¯´è¯äºº
        async function batchUpdateSpeaker() {
            if (selectedSegmentIds.size === 0) {
                showToast('è¯·å…ˆé€‰æ‹©è¦ä¿®æ”¹çš„æ®µè½');
                return;
            }
            
            const newSpeaker = document.getElementById('batchSpeakerSelect').value;
            if (!newSpeaker) {
                showToast('è¯·é€‰æ‹©è¦è®¾ç½®çš„è¯´è¯äºº');
                return;
            }
            
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }
            
            // ç¡®è®¤æ“ä½œ
            if (!confirm(`ç¡®å®šè¦å°†é€‰ä¸­çš„ ${selectedSegmentIds.size} ä¸ªæ®µè½çš„è¯´è¯äººä¿®æ”¹ä¸º ${newSpeaker} å—ï¼Ÿ`)) {
                return;
            }
            
            const batchUpdateBtn = document.getElementById('batchUpdateBtn');
            const originalText = batchUpdateBtn.innerHTML;
            batchUpdateBtn.disabled = true;
            batchUpdateBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>æ­£åœ¨ä¿®æ”¹...';
            
            try {
                addLog(`å¼€å§‹æ‰¹é‡ä¿®æ”¹è¯´è¯äºº: ${selectedSegmentIds.size}ä¸ªæ®µè½ â†’ ${newSpeaker}`);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/batch-update-speaker`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        segment_ids: Array.from(selectedSegmentIds),
                        speaker: newSpeaker
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const updatedCount = result.updated_count || selectedSegmentIds.size;
                    addLog(`æ‰¹é‡ä¿®æ”¹è¯´è¯äººæˆåŠŸ: ${updatedCount}ä¸ªæ®µè½å·²æ›´æ–°`);
                    showToast(`æˆåŠŸä¿®æ”¹ ${updatedCount} ä¸ªæ®µè½çš„è¯´è¯äººä¸º ${newSpeaker}`);
                    
                    // æ¸…é™¤é€‰æ‹©å¹¶é‡æ–°åŠ è½½æ®µè½
                    clearAllSelections();
                    await loadSubtitleSegments();
                } else {
                    addLog(`æ‰¹é‡ä¿®æ”¹è¯´è¯äººå¤±è´¥: ${result.message}`);
                    showToast('æ‰¹é‡ä¿®æ”¹å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('æ‰¹é‡ä¿®æ”¹è¯´è¯äººå¤±è´¥:', error);
                addLog(`æ‰¹é‡ä¿®æ”¹è¯´è¯äººå¤±è´¥: ${error.message}`);
                showToast('æ‰¹é‡ä¿®æ”¹å¤±è´¥: ' + error.message);
            } finally {
                batchUpdateBtn.disabled = false;
                batchUpdateBtn.innerHTML = originalText;
            }
        }

        // åˆ‡æ¢æ‰¹é‡è¯´è¯äººé¢æ¿æ˜¾ç¤º
        function toggleBatchSpeakerPanel() {
            const panel = document.getElementById('batchSpeakerPanel');
            const toggle = document.getElementById('batchSpeakerToggle');
            
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                toggle.classList.remove('btn-outline-primary');
                toggle.classList.add('btn-primary');
                toggle.innerHTML = '<i class="bi bi-people-fill me-1"></i>å…³é—­é¢æ¿';
            } else {
                panel.style.display = 'none';
                toggle.classList.remove('btn-primary');
                toggle.classList.add('btn-outline-primary');
                toggle.innerHTML = '<i class="bi bi-people-fill me-1"></i>æ‰¹é‡æ”¹è¯´è¯äºº';
            }
        }
    </script>
    <script>
        // åœæ­¢è¿›åº¦æ›´æ–°
        function stopProgressUpdate() {
            if (audioUpdateTimer) {
                clearInterval(audioUpdateTimer);
                audioUpdateTimer = null;
            }
        }
        
        // ç”ŸæˆéŸ³é¢‘æ³¢å½¢
        async function generateWaveform(audioUrl, canvas) {
            try {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, width, height);
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // è·å–éŸ³é¢‘æ•°æ®
                const response = await fetch(audioUrl);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // è·å–éŸ³é¢‘æ•°æ®
                const channelData = audioBuffer.getChannelData(0);
                const dataLength = channelData.length;
                
                // è®¡ç®—é‡‡æ ·é—´éš”
                const sampleStep = Math.ceil(dataLength / width);
                const samples = [];
                
                // é‡‡æ ·æ•°æ®
                for (let i = 0; i < width; i++) {
                    const start = i * sampleStep;
                    const end = Math.min(start + sampleStep, dataLength);
                    let sum = 0;
                    let count = 0;
                    
                    for (let j = start; j < end; j++) {
                        sum += Math.abs(channelData[j]);
                        count++;
                    }
                    
                    samples.push(sum / count);
                }
                
                // å­˜å‚¨æ³¢å½¢æ•°æ®
                waveformData = samples;
                
                // ç»˜åˆ¶æ³¢å½¢
                drawWaveform(ctx, samples, width, height);
                
            } catch (error) {
                console.error('æ³¢å½¢ç”Ÿæˆå¤±è´¥:', error);
                // ç»˜åˆ¶é”™è¯¯æç¤º
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#6c757d';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ³¢å½¢åŠ è½½å¤±è´¥', canvas.width / 2, canvas.height / 2);
            }
        }
        
        // ç»˜åˆ¶æ³¢å½¢
        function drawWaveform(ctx, samples, width, height) {
            const centerY = height / 2;
            const maxAmplitude = Math.max(...samples);
            
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < samples.length; i++) {
                const x = i;
                const amplitude = (samples[i] / maxAmplitude) * (height / 2);
                const y1 = centerY - amplitude;
                const y2 = centerY + amplitude;
                
                ctx.moveTo(x, y1);
                ctx.lineTo(x, y2);
            }
            
            ctx.stroke();
        }
        
        // æ›´æ–°æ³¢å½¢æ’­æ”¾ä½ç½®
        function updateWaveformPosition(progress) {
            if (!waveformData) return;
            
            const canvas = document.getElementById('audioWaveform');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // é‡æ–°ç»˜åˆ¶æ³¢å½¢
            drawWaveform(ctx, waveformData, width, height);
            
            // ç»˜åˆ¶æ’­æ”¾ä½ç½®æŒ‡ç¤ºå™¨
            const playPosition = progress * width;
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playPosition, 0);
            ctx.lineTo(playPosition, height);
            ctx.stroke();
        }
        
        // å¼€å§‹æ³¢å½¢æ›´æ–°
        function startWaveformUpdate() {
            // æ³¢å½¢æ›´æ–°å·²ç»é›†æˆåˆ°è¿›åº¦æ›´æ–°ä¸­
        }
        
        // åœæ­¢æ³¢å½¢æ›´æ–°
        function stopWaveformUpdate() {
            // æ³¢å½¢æ›´æ–°å·²ç»é›†æˆåˆ°è¿›åº¦æ›´æ–°ä¸­ï¼Œä¸éœ€è¦å•ç‹¬åœæ­¢
        }
        
        // æ ¼å¼åŒ–æ—¶é—´ï¼ˆç”¨äºéŸ³é¢‘æ’­æ”¾æ—¶é•¿æ˜¾ç¤ºï¼‰
        function formatPlaybackTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    </script>
    <script>
        
        // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨çŠ¶æ€
        function initAudioPlayerState() {
            const playBtn = document.getElementById('mergePlayBtn');
            const pauseBtn = document.getElementById('mergePauseBtn');
            const audioStatus = document.getElementById('audioStatus');
            const waveformCanvas = document.getElementById('audioWaveform');
            
            // æ£€æŸ¥å¿…è¦çš„DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!playBtn || !pauseBtn || !audioStatus || !waveformCanvas) {
                console.error('Some audio player state elements not found');
                return;
            }
            
            // ç¡®ä¿æ’­æ”¾å™¨é»˜è®¤æ˜¾ç¤ºä½†ç¦ç”¨
            playBtn.disabled = true;
            pauseBtn.disabled = true;
            
            // åˆå§‹åŒ–æ³¢å½¢æ˜¾ç¤ºç­‰å¾…çŠ¶æ€
            const ctx = waveformCanvas.getContext('2d');
            ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            ctx.fillStyle = '#6c757d';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ç­‰å¾…éŸ³é¢‘æ•°æ®...', waveformCanvas.width / 2, waveformCanvas.height / 2);
            
            // è®¾ç½®é»˜è®¤çŠ¶æ€æç¤º
            audioStatus.innerHTML = ``;
        }
    </script>
    <script>
        // å­˜å‚¨å½“å‰æ“ä½œçš„å®¢æˆ·ç«¯ID
        let currentOperationClientId = null;
        
        // ä¸­æ–­å½“å‰ä»»åŠ¡å‡½æ•°
        async function interruptCurrentTask() {
            if (!currentSubtitleProject || !currentOperationClientId) {
                showToast('æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡');
                return;
            }
            
            try {
                addLog('ç”¨æˆ·è¯·æ±‚ä¸­æ–­ä»»åŠ¡...');
                showToast('æ­£åœ¨ä¸­æ–­ä»»åŠ¡...');
                
                const response = await fetch(`/api/interrupt/${currentOperationClientId}`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog('ä¸­æ–­è¯·æ±‚å·²å‘é€');
                    showToast('ä»»åŠ¡ä¸­æ–­è¯·æ±‚å·²å‘é€');
                } else {
                    addLog(`ä¸­æ–­å¤±è´¥: ${result.message}`);
                    showToast('ä»»åŠ¡ä¸­æ–­å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('ä¸­æ–­ä»»åŠ¡å¤±è´¥:', error);
                addLog(`ä¸­æ–­ä»»åŠ¡å¤±è´¥: ${error.message}`);
                showToast('ä¸­æ–­ä»»åŠ¡å¤±è´¥: ' + error.message);
            }
        }
        

        // ä¸€é”®ç¿»è¯‘å‡½æ•° - è‡ªåŠ¨æŒ‰é¡ºåºæ‰§è¡Œç¿»è¯‘ã€TTSã€åˆå¹¶
        async function oneClickTranslate() {
            console.log('ä¸€é”®ç¿»è¯‘æŒ‰é’®è¢«ç‚¹å‡»');
            if (!currentSubtitleProject) {
                showToast('è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶');
                return;
            }
            
            // è·å–APIé…ç½®
            const groupId = document.getElementById('groupId').value;
            const apiKey = document.getElementById('apiKey').value;
            
            if (!groupId || !apiKey) {
                addLog('é…ç½®é”™è¯¯: ç¼ºå°‘Group IDæˆ–API Key');
                showToast('è¯·å…ˆé…ç½®Group IDå’ŒAPI Key');
                return;
            }
            
            // è·å–ç¿»è¯‘è¯­è¨€
            const targetLanguage = document.getElementById('language').value;
            if (!targetLanguage) {
                showToast('è¯·é€‰æ‹©ç›®æ ‡è¯­è¨€');
                return;
            }
            
            // ç¦ç”¨ä¸€é”®ç¿»è¯‘æŒ‰é’®
            const oneClickBtn = document.getElementById('oneClickTranslateBtn');
            const originalText = oneClickBtn.innerHTML;
            oneClickBtn.disabled = true;
            oneClickBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>æ­£åœ¨å¤„ç†...';
            
            // ç”Ÿæˆå®¢æˆ·ç«¯IDç”¨äºä¸€é”®ç¿»è¯‘
            currentOperationClientId = generateClientId();
            
            try {
                addLog('=== å¼€å§‹ä¸€é”®ç¿»è¯‘æµç¨‹ ===');
                showToast('å¼€å§‹ä¸€é”®ç¿»è¯‘æµç¨‹...');
                
                // ç¬¬ä¸€æ­¥ï¼šæ‰¹é‡ç¿»è¯‘
                addLog('æ­¥éª¤1: å¼€å§‹æ‰¹é‡ç¿»è¯‘...');
                const translateResult = await executeBatchTranslate(targetLanguage, groupId, apiKey);
                if (!translateResult.success) {
                    throw new Error(`ç¿»è¯‘å¤±è´¥: ${translateResult.message}`);
                }
                addLog('æ­¥éª¤1: æ‰¹é‡ç¿»è¯‘å®Œæˆ');
                
                // ç¬¬äºŒæ­¥ï¼šæ‰¹é‡TTS
                addLog('æ­¥éª¤2: å¼€å§‹æ‰¹é‡TTS...');
                const ttsResult = await executeBatchTTS(groupId, apiKey);
                if (!ttsResult.success) {
                    throw new Error(`TTSå¤±è´¥: ${ttsResult.message}`);
                }
                addLog('æ­¥éª¤2: æ‰¹é‡TTSå®Œæˆ');
                
                // ç¬¬ä¸‰æ­¥ï¼šæ‹¼æ¥éŸ³é¢‘
                addLog('æ­¥éª¤3: å¼€å§‹æ‹¼æ¥éŸ³é¢‘...');
                const mergeResult = await executeMergeAudio();
                if (!mergeResult.success) {
                    throw new Error(`æ‹¼æ¥å¤±è´¥: ${mergeResult.message}`);
                }
                addLog('æ­¥éª¤3: æ‹¼æ¥éŸ³é¢‘å®Œæˆ');
                
                addLog('=== ä¸€é”®ç¿»è¯‘æµç¨‹å®Œæˆ ===');
                showToast('ä¸€é”®ç¿»è¯‘å®Œæˆï¼éŸ³é¢‘å·²å‡†å¤‡å°±ç»ª');
                
            } catch (error) {
                console.error('ä¸€é”®ç¿»è¯‘å¤±è´¥:', error);
                addLog(`ä¸€é”®ç¿»è¯‘å¤±è´¥: ${error.message}`);
                showToast('ä¸€é”®ç¿»è¯‘å¤±è´¥: ' + error.message);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€ï¼Œæ¸…é™¤å®¢æˆ·ç«¯ID
                oneClickBtn.disabled = false;
                oneClickBtn.innerHTML = originalText;
                currentOperationClientId = null;
            }
        }

        // æ‰§è¡Œæ‰¹é‡ç¿»è¯‘çš„è¾…åŠ©å‡½æ•°
        async function executeBatchTranslate(targetLanguage, groupId, apiKey) {
            startRealTimeLogUpdates(currentOperationClientId);
            
            try {
                const formData = new FormData();
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('apiEndpoint', document.getElementById('apiEndpoint').value);
                formData.append('target_language', targetLanguage);
                formData.append('clientId', currentOperationClientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/batch-translate`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                stopRealTimeLogUpdates();
                
                if (result.success) {
                    loadSubtitleSegments(); // é‡æ–°åŠ è½½ä»¥æ˜¾ç¤ºç¿»è¯‘ç»“æœ
                }
                
                return result;
            } catch (error) {
                stopRealTimeLogUpdates();
                return { success: false, message: error.message };
            }
        }

        // æ‰§è¡Œæ‰¹é‡TTSçš„è¾…åŠ©å‡½æ•°
        async function executeBatchTTS(groupId, apiKey) {
            startRealTimeLogUpdates(currentOperationClientId);
            
            try {
                const formData = new FormData();
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('apiEndpoint', document.getElementById('apiEndpoint').value);
                formData.append('model', document.getElementById('voiceModel').value);
                formData.append('language', document.getElementById('language').value);
                formData.append('voiceMapping', JSON.stringify(getVoiceMapping()));
                formData.append('clientId', currentOperationClientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/batch-generate-tts`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                stopRealTimeLogUpdates();
                
                if (result.success) {
                    loadSubtitleSegments(); // é‡æ–°åŠ è½½ä»¥æ˜¾ç¤ºTTSç»“æœ
                }
                
                return result;
            } catch (error) {
                stopRealTimeLogUpdates();
                return { success: false, message: error.message };
            }
        }

        // æ‰§è¡Œæ‹¼æ¥éŸ³é¢‘çš„è¾…åŠ©å‡½æ•°
        async function executeMergeAudio() {
            startRealTimeLogUpdates(currentOperationClientId);
            
            try {
                const formData = new FormData();
                formData.append('clientId', currentOperationClientId);
                
                const response = await fetch(`/api/subtitle/${currentSubtitleProject.id}/merge-audio`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                stopRealTimeLogUpdates();
                
                if (result.success) {
                    showMergeResult(result);
                }
                
                return result;
            } catch (error) {
                stopRealTimeLogUpdates();
                return { success: false, message: error.message };
            }
        }

        // æ–‡æœ¬é•¿åº¦è°ƒæ•´å‡½æ•°
        async function adjustSegmentText(segmentId, adjustmentType) {
            if (!currentSubtitleProject) {
                addLog('æ“ä½œé”™è¯¯: è¯·å…ˆä¸Šä¼ SRTæ–‡ä»¶', 'error');
                return;
            }

            // è·å–å½“å‰é…ç½®
            const groupId = document.getElementById('groupId')?.value;
            const apiKey = document.getElementById('apiKey')?.value;
            const targetLanguage = document.getElementById('language')?.value;
            const apiEndpoint = document.getElementById('apiEndpoint')?.value || 'domestic';

            if (!groupId || !apiKey) {
                addLog('é…ç½®é”™è¯¯: è¯·å…ˆå¡«å†™APIé…ç½®ä¿¡æ¯', 'error');
                return;
            }

            if (!targetLanguage) {
                addLog('é…ç½®é”™è¯¯: è¯·å…ˆé€‰æ‹©ç›®æ ‡è¯­è¨€', 'error');
                return;
            }

            // æŸ¥æ‰¾æŒ‰é’®å¹¶è®¾ç½®åŠ è½½çŠ¶æ€
            const buttons = document.querySelectorAll(`[data-segment-id="${segmentId}"].text-adjust-btn`);
            const targetButton = Array.from(buttons).find(btn => btn.dataset.adjustmentType === adjustmentType);
            
            if (!targetButton) {
                return;
            }

            const originalText = targetButton.innerHTML;
            const actionText = adjustmentType === 'shorten' ? 'ç¼©çŸ­' : 'åŠ é•¿';
            
            // ç¦ç”¨æ‰€æœ‰è°ƒæ•´æŒ‰é’®
            buttons.forEach(btn => btn.disabled = true);
            targetButton.innerHTML = `<span class="spinner-border spinner-border-sm me-1"></span>${actionText}ä¸­...`;

            try {
                // å‡†å¤‡è¡¨å•æ•°æ®
                const formData = new FormData();
                formData.append('adjustment_type', adjustmentType);
                formData.append('groupId', groupId);
                formData.append('apiKey', apiKey);
                formData.append('target_language', targetLanguage);
                formData.append('apiEndpoint', apiEndpoint);

                // å‘é€è°ƒæ•´è¯·æ±‚
                const url = `/api/subtitle/${currentSubtitleProject.id}/segment/${segmentId}/adjust-text`;
                const response = await fetch(url, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    // è®°å½•æˆåŠŸä¿¡æ¯åˆ°æ—¥å¿—ï¼Œä¸æ˜¾ç¤ºå¼¹çª—
                    const changeInfo = result.length_change;
                    const changeText = changeInfo.change_percentage > 0 ? 
                        `å¢åŠ ${changeInfo.change_percentage}%` : 
                        `å‡å°‘${Math.abs(changeInfo.change_percentage)}%`;
                    
                    addLog(`æ–‡æœ¬${actionText}æˆåŠŸ: ${changeInfo.original_length} â†’ ${changeInfo.new_length} å­— (${changeText})`, 'success');

                    // æ›´æ–°æ®µè½æ˜¾ç¤ºä¸­çš„è¯‘æ–‡
                    const translationElement = document.querySelector(`[data-segment-id="${segmentId}"] .translation-text`);
                    if (translationElement) {
                        translationElement.textContent = `è¯‘æ–‡: ${result.adjusted_text}`;
                        
                        // æ·»åŠ æ›´æ–°åŠ¨ç”»æ•ˆæœ
                        translationElement.style.backgroundColor = '#d4edda';
                        translationElement.style.border = '1px solid #c3e6cb';
                        translationElement.style.borderRadius = '0.25rem';
                        translationElement.style.padding = '0.25rem';
                        setTimeout(() => {
                            translationElement.style.backgroundColor = '';
                            translationElement.style.border = '';
                            translationElement.style.borderRadius = '';
                            translationElement.style.padding = '';
                        }, 2000);
                    }

                    // æ›´æ–°segmentsæ•°ç»„ä¸­çš„æ•°æ®
                    const segmentIndex = segments.findIndex(s => s.id === segmentId);
                    if (segmentIndex !== -1) {
                        segments[segmentIndex].translated_text = result.adjusted_text;
                    }
                    
                    // é‡æ–°åŠ è½½æ®µè½æ•°æ®ä»¥ç¡®ä¿é¡¹ç›®ä¸­çš„æ•°æ®ä¹Ÿæ˜¯æœ€æ–°çš„
                    await loadSubtitleSegments();
                    
                    // è®°å½•åˆ°æ—¥å¿—
                    addLog(`æ®µè½ ${segmentId} æ–‡æœ¬${actionText}æˆåŠŸï¼š${changeInfo.original_length} â†’ ${changeInfo.new_length} å­—`, 'success');
                } else {
                    throw new Error(result.message || `æ–‡æœ¬${actionText}å¤±è´¥`);
                }

            } catch (error) {
                console.error(`æ–‡æœ¬${actionText}å¤±è´¥:`, error);
                addLog(`æ–‡æœ¬${actionText}å¤±è´¥: ${error.message}`, 'error');
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                buttons.forEach(btn => btn.disabled = false);
                targetButton.innerHTML = originalText;
            }
        }

        // è·å–å½“å‰é¡¹ç›®IDçš„è¾…åŠ©å‡½æ•°
        function getCurrentProjectId() {
            return currentSubtitleProject ? currentSubtitleProject.id : null;
        }

        // ================== è‡ªå®šä¹‰è§’è‰²ç®¡ç†åŠŸèƒ½ ==================

        // æ˜¾ç¤ºæ·»åŠ è§’è‰²æ¨¡æ€æ¡†
        function showAddSpeakerModal() {
            // æ¸…ç©ºè¡¨å•
            document.getElementById('speakerVoiceId').value = '';
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            const modal = new bootstrap.Modal(document.getElementById('addSpeakerModal'));
            modal.show();
        }

        // æ·»åŠ è‡ªå®šä¹‰è§’è‰²
        async function addCustomSpeaker() {
            const voiceId = document.getElementById('speakerVoiceId').value.trim();

            if (!voiceId) {
                addLog('è¯·å¡«å†™è¯­éŸ³ID', 'error');
                return;
            }

            try {
                const formData = new FormData();
                formData.append('voice_id', voiceId);

                const response = await fetch('/api/custom-speakers', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`âœ… æˆåŠŸæ·»åŠ è‡ªå®šä¹‰è§’è‰²: ${result.speaker.name}`, 'success');
                    
                    // å…³é—­æ¨¡æ€æ¡†
                    const modal = bootstrap.Modal.getInstance(document.getElementById('addSpeakerModal'));
                    modal.hide();
                    
                    // åˆ·æ–°è‡ªå®šä¹‰è§’è‰²åˆ—è¡¨
                    await loadCustomSpeakers();
                    
                    // æ›´æ–°è¯´è¯äººé€‰æ‹©å™¨
                    updateSpeakerSelectors();
                } else {
                    addLog(`âŒ æ·»åŠ è§’è‰²å¤±è´¥: ${result.detail || result.message}`, 'error');
                }
            } catch (error) {
                console.error('æ·»åŠ è‡ªå®šä¹‰è§’è‰²å¤±è´¥:', error);
                addLog(`âŒ æ·»åŠ è§’è‰²å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åŠ è½½è‡ªå®šä¹‰è§’è‰²åˆ—è¡¨
        async function loadCustomSpeakers() {
            try {
                const response = await fetch('/api/custom-speakers');
                const result = await response.json();

                if (result.success) {
                    renderCustomSpeakers(result.speakers);
                }
            } catch (error) {
                console.error('åŠ è½½è‡ªå®šä¹‰è§’è‰²å¤±è´¥:', error);
            }
        }

        // æ¸²æŸ“è‡ªå®šä¹‰è§’è‰²åˆ—è¡¨
        function renderCustomSpeakers(speakers) {
            const container = document.getElementById('customSpeakersContainer');
            
            if (speakers.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div class="border-top pt-3 mt-3"><h6 class="text-muted mb-3">è‡ªå®šä¹‰è§’è‰²</h6>';
            
            speakers.forEach((speaker, index) => {
                const rowClass = index % 2 === 0 ? 'row g-3 mb-3' : 'row g-3 mb-3';
                const colClass = index % 2 === 0 ? 'col-6' : 'col-6';
                
                if (index % 2 === 0) {
                    html += '<div class="row g-3 mb-3">';
                }
                
                html += `
                    <div class="${colClass}">
                        <div class="d-flex align-items-center">
                            <div class="flex-grow-1">
                                <label class="form-label small">${speaker.name}</label>
                                <input type="text" class="form-control form-control-sm" 
                                       id="customSpeaker_${speaker.id}" 
                                       value="${speaker.voice_id}"
                                       data-speaker-id="${speaker.id}"
                                       data-speaker-name="${speaker.name}"
                                       onchange="updateCustomSpeakerVoice('${speaker.id}', this.value)">
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger ms-2" 
                                    onclick="deleteCustomSpeaker('${speaker.id}', '${speaker.name}')"
                                    title="åˆ é™¤è§’è‰²">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                if (index % 2 === 1 || index === speakers.length - 1) {
                    html += '</div>';
                }
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // æ›´æ–°è‡ªå®šä¹‰è§’è‰²è¯­éŸ³
        async function updateCustomSpeakerVoice(speakerId, voiceId) {
            try {
                const formData = new FormData();
                formData.append('voice_id', voiceId);

                const response = await fetch(`/api/custom-speakers/${speakerId}`, {
                    method: 'PUT',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`âœ… å·²æ›´æ–°è§’è‰²è¯­éŸ³: ${result.speaker.name} -> ${voiceId}`, 'success');
                    saveCustomSpeakersConfig(); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                } else {
                    addLog(`âŒ æ›´æ–°è§’è‰²è¯­éŸ³å¤±è´¥: ${result.detail || result.message}`, 'error');
                }
            } catch (error) {
                console.error('æ›´æ–°è‡ªå®šä¹‰è§’è‰²è¯­éŸ³å¤±è´¥:', error);
                addLog(`âŒ æ›´æ–°è§’è‰²è¯­éŸ³å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ é™¤è‡ªå®šä¹‰è§’è‰²
        async function deleteCustomSpeaker(speakerId, speakerName) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰è§’è‰² "${speakerName}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
                return;
            }

            try {
                const response = await fetch(`/api/custom-speakers/${speakerId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`âœ… å·²åˆ é™¤è‡ªå®šä¹‰è§’è‰²: ${speakerName}`, 'success');
                    
                    // åˆ·æ–°è‡ªå®šä¹‰è§’è‰²åˆ—è¡¨
                    await loadCustomSpeakers();
                    
                    // æ›´æ–°è¯´è¯äººé€‰æ‹©å™¨
                    updateSpeakerSelectors();
                } else {
                    addLog(`âŒ åˆ é™¤è§’è‰²å¤±è´¥: ${result.detail || result.message}`, 'error');
                }
            } catch (error) {
                console.error('åˆ é™¤è‡ªå®šä¹‰è§’è‰²å¤±è´¥:', error);
                addLog(`âŒ åˆ é™¤è§’è‰²å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ›´æ–°è¯´è¯äººé€‰æ‹©å™¨ï¼ˆæ‰¹é‡æ“ä½œå’Œå…¶ä»–åœ°æ–¹ä½¿ç”¨ï¼‰
        async function updateSpeakerSelectors() {
            try {
                const response = await fetch('/api/all-speakers');
                const result = await response.json();

                if (result.success) {
                    // æ›´æ–°æ‰¹é‡è¯´è¯äººé€‰æ‹©å™¨
                    const batchSelect = document.getElementById('batchSpeakerSelect');
                    if (batchSelect) {
                        const currentValue = batchSelect.value;
                        batchSelect.innerHTML = '<option value="">é€‰æ‹©è¯´è¯äºº</option>';
                        
                        result.all_speaker_names.forEach(speakerName => {
                            const option = document.createElement('option');
                            option.value = speakerName;
                            option.textContent = speakerName;
                            batchSelect.appendChild(option);
                        });
                        
                        // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
                        if (currentValue) {
                            batchSelect.value = currentValue;
                        }
                    }
                }
            } catch (error) {
                console.error('æ›´æ–°è¯´è¯äººé€‰æ‹©å™¨å¤±è´¥:', error);
            }
        }

        // ä¿å­˜è‡ªå®šä¹‰è§’è‰²é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
        function saveCustomSpeakersConfig() {
            const customInputs = document.querySelectorAll('[id^="customSpeaker_"]');
            const config = {};
            
            customInputs.forEach(input => {
                const speakerId = input.dataset.speakerId;
                const speakerName = input.dataset.speakerName;
                config[speakerId] = {
                    name: speakerName,
                    voice_id: input.value
                };
            });
            
            try {
                localStorage.setItem('custom_speakers_config', JSON.stringify(config));
            } catch (error) {
                console.error('ä¿å­˜è‡ªå®šä¹‰è§’è‰²é…ç½®å¤±è´¥:', error);
            }
        }

        // åŠ è½½è‡ªå®šä¹‰è§’è‰²é…ç½®
        function loadCustomSpeakersConfig() {
            try {
                const saved = localStorage.getItem('custom_speakers_config');
                if (saved) {
                    const config = JSON.parse(saved);
                    
                    Object.keys(config).forEach(speakerId => {
                        const input = document.getElementById(`customSpeaker_${speakerId}`);
                        if (input && config[speakerId].voice_id) {
                            input.value = config[speakerId].voice_id;
                        }
                    });
                }
            } catch (error) {
                console.error('åŠ è½½è‡ªå®šä¹‰è§’è‰²é…ç½®å¤±è´¥:', error);
            }
        }
    </script>
</body>
</html> 
